const ExcelJS = require('exceljs');
const fs = require('fs');
const path = require('path');
const logger = require('../utils/logger');
const CurrencyUtils = require('../utils/currency');
const axios = require('axios');

class XlsxGeneratorService {
    constructor() {
        this.outputDir = path.join(__dirname, '../storage/generated-reports');
        this.ensureOutputDir();
        
        this.workbook = new ExcelJS.Workbook();
        
        // Configurar encoding explicitamente para UTF-8
        this.workbook.creator = 'FluxoClienteCS';
        this.workbook.lastModifiedBy = 'FluxoClienteCS';
        this.workbook.created = new Date();
        this.workbook.modified = new Date();
        this.workbook.calcProperties.fullCalcOnLoad = true;
        
        this.worksheet = null;
        this.currentRow = 1;
        this.dataRows = []; // Array para armazenar todas as linhas antes da escrita
        
        this.boldLabels = [
            'Apelido:', 'C√≥digo no sistema Dom√≠nio:', 'Raz√£o Social:', 'CNPJ:', 
            'Vig√™ncia Inicial:', 'Site:', 'Plano Contratado:', 'SLA Para Retorno:',
            'Servi√ßos Contratados', 'Servi√ßo 1:', 'Servi√ßo 2:', 'Servi√ßo 3:', 'Servi√ßo 4:', 'Servi√ßo 5:', 'Servi√ßo 6:',
            'Contato Principal', 'Nome:', 'Cargo:', 'E-mail:', 'Celular:',
            'Entendimento do Neg√≥cio', 'Faturamento anual:', 'Regime Tribut√°rio:',
            'NF de Entrada:', 'NF de Sa√≠da:', 'CT-es de Entrada:', 'CT-es de Sa√≠da:',
            'NF de Prestados:', 'NF de Tomados:', 'Funcion√°rios PJ:', 'Centros de Custo:',
            'Folha de Pagamento', 'Funcion√°rios CLT:', 'Pr√≥-Labore:', 'Estagi√°rios:',
            'Aprendizes:', 'Aut√¥nomos - RPA:', 'Dom√©sticas CLT:', 'Sistemas',
            'Cont√°bil e Fiscal:', 'Contabilidade e Fiscal', 'Deadline:', 'CNAE:',
            'Comercial', 'Closer:', 'Prospector:', 'Obs Closer:', 'Obs:'
        ];

        // Definir estilos
        this.styles = {
            default: {
                font: { name: 'Calibri', size: 11 },
                alignment: { vertical: 'top', horizontal: 'left' }
            },
            bold: {
                font: { name: 'Calibri', size: 11, bold: true },
                alignment: { vertical: 'top', horizontal: 'left' }
            },
            sectionHeader: {
                font: { name: 'Calibri', size: 12, bold: true },
                alignment: { vertical: 'top', horizontal: 'left' },
                fill: { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFADDBDC' } }
            },
            mainHeader: {
                font: { name: 'Calibri', size: 25, bold: true, color: { argb: 'FF000000' } },
                alignment: { vertical: 'middle', horizontal: 'left' }
            },
            companyName: {
                font: { name: 'Calibri', size: 11, bold: true },
                alignment: { vertical: 'top', horizontal: 'left' }
            }
        };

        // Lista de nomes de empresas para aplicar negrito
        this.companyNames = [];
        
        // Configura√ß√£o de truncamento
        this.maxCompanyNameLength = 52;
    }

    ensureOutputDir() {
        if (!fs.existsSync(this.outputDir)) {
            fs.mkdirSync(this.outputDir, { recursive: true });
            logger.info('üìÅ Diret√≥rio de relat√≥rios criado', { path: this.outputDir });
        }
    }

    // Fun√ß√£o para converter valores para n√∫meros nativos (evita "n√∫mero armazenado como texto")
    convertToNumber(value, defaultValue = 0) {
        if (value === null || value === undefined || value === '') {
            return defaultValue;
        }
        
        // Se j√° √© um n√∫mero, retorna como est√°
        if (typeof value === 'number') {
            return value;
        }
        
        // Se √© string, tenta converter para n√∫mero
        if (typeof value === 'string') {
            const trimmed = value.trim();
            
            // Se string vazia ap√≥s trim, retorna default
            if (trimmed === '') {
                return defaultValue;
            }
            
            // Tenta converter para n√∫mero
            const parsed = parseFloat(trimmed);
            
            // Se convers√£o foi bem sucedida e √© um n√∫mero v√°lido
            if (!isNaN(parsed) && isFinite(parsed)) {
                return parsed;
            }
        }
        
        // Se n√£o conseguiu converter, retorna o valor original
        return value;
    }

    truncateCompanyName(name) {
        if (!name) return '';
        const nameStr = String(name).trim();
        if (nameStr.length <= this.maxCompanyNameLength) {
            return nameStr;
        }
        const truncated = nameStr.substring(0, this.maxCompanyNameLength - 3) + '...';
        logger.info(`‚úÇÔ∏è Nome truncado: "${nameStr}" ‚Üí "${truncated}" (${nameStr.length} ‚Üí ${truncated.length} chars)`);
        return truncated;
    }

    // Fun√ß√£o para truncar nome da empresa para o cabe√ßalho (25 chars)
    truncateCompanyNameHeader(name) {
        if (!name) return '';
        const nameStr = String(name).trim();
        const maxLength = 25;
        if (nameStr.length <= maxLength) {
            return nameStr;
        }
        const truncated = nameStr.substring(0, maxLength - 3) + '...';
        logger.info(`‚úÇÔ∏è Nome truncado para header: "${nameStr}" ‚Üí "${truncated}" (${nameStr.length} ‚Üí ${truncated.length} chars)`);
        return truncated;
    }

    // Normaliza diferentes formatos/vers√µes de payloads de empresa para o shape esperado
    normalizeCompany(raw) {
        if (!raw) return raw;

        // Mantemos todas as chaves originais e garantimos aliases para os campos cr√≠ticos
        const c = { ...raw };

        // Campos comuns/aliases
        c.nome_fantasia = raw.nome_fantasia || raw.nome || raw.name || raw.company || '';
        c.razao_social = raw.razao_social || raw.razao || raw.company_name || raw.razaoSocial || '';
        c.codigo = raw.codigo || raw.id || raw.code || raw.codigo_empresa || '';
        c.grupo = raw.grupo || raw.group || raw.groupName || raw.grupo_nome || '';
        c.inicio_contrato = raw.inicio_contrato || raw.data_inicio || raw.start_date || raw.inicio || raw.inicioContrato || null;
        c.cnpj = raw.cnpj || raw.cpf || raw.documento || '';
        c.faturamento_anual = raw.faturamento_anual || raw.faturamento || raw.revenue || '';

        // CORRE√á√ÉO INTELIGENTE DE DADOS DESALINHADOS
        c = this.fixDataMisalignment(c);

        // Keep originals for any other property; return normalized object
        return c;
    }

    // Fun√ß√£o para corrigir dados desalinhados da API
    fixDataMisalignment(company) {
        const fixed = { ...company };
        
        // CORRE√á√ÉO 1: CONTATOS DESALINHADOS
        const nome = company.contato_principal_nome || '';
        const cargo = company.contato_principal_cargo || '';
        const email = company.contato_principal_email || '';
        const celular = company.contato_principal_celular || '';
        
        // Detectar deslocamento nos contatos
        if (!nome.trim() && cargo.trim() && !cargo.includes('@')) {
            logger.info('üîß Corrigindo desalinhamento de contatos para:', company.nome_fantasia);
            
            // Contatos deslocados: cargo‚Üínome, email‚Üícargo, celular‚Üíemail
            fixed.contato_principal_nome = cargo;
            fixed.contato_principal_cargo = email;
            fixed.contato_principal_email = celular;
            
            // Buscar celular no plano_contratado
            const plano = company.plano_contratado || '';
            if (plano.includes('+55') || plano.match(/\(\d{2}\)|\d{4,5}-?\d{4}/)) {
                fixed.contato_principal_celular = plano;
                logger.info(`üì± Celular movido de plano_contratado: "${plano}"`);
                
                // CORRE√á√ÉO 2: PLANO/SLA DESALINHADOS
                // Se celular estava em plano_contratado, plano real est√° em sla
                const slaOriginal = company.sla || '';
                fixed.plano_contratado = slaOriginal;
                fixed.sla = 'Conforme necessidade'; // SLA padr√£o
                logger.info(`üìã Plano movido de sla: "${slaOriginal}"`);
            } else {
                fixed.contato_principal_celular = '';
            }
        }
        
        // CORRE√á√ÉO 2.1: PLANO/SLA SEMPRE VERIFICAR (mesmo sem deslocamento de contatos)
        const planoAtual = fixed.plano_contratado || '';
        const slaAtual = fixed.sla || '';
        
        // Se plano tem formato de telefone, mas SLA tem texto de plano
        if (planoAtual.includes('+55') && slaAtual && !slaAtual.includes('+55')) {
            const temp = fixed.plano_contratado;
            fixed.plano_contratado = fixed.sla;
            fixed.sla = 'Conforme necessidade';
            logger.info(`üîÑ Corrigido plano/SLA: "${temp}" ‚Üî "${fixed.plano_contratado}"`);
        }
        
        // CORRE√á√ÉO 2.2: IMPLANTA√á√ÉO DESALINHADA
        const implantacao = company.implantacao || '';
        const vencimentoImplantacao = company.vencimento_implantacao || '';
        
        // Se implanta√ß√£o est√° vazia mas vencimento tem "N√£o"
        if (!implantacao.trim() && vencimentoImplantacao === 'N√£o') {
            fixed.implantacao = 'N√£o';
            fixed.vencimento_implantacao = '';
            logger.info(`üìÖ Corrigido implanta√ß√£o: vazia ‚Üí "N√£o"`);
        }
        
        // CORRE√á√ÉO 3: VALORES BPO INCONSISTENTES
        // Se vl_bpo_contabil tem string "N√£o" em vez de valor, corrigir
        if (fixed.vl_bpo_contabil === 'N√£o') {
            fixed.vl_bpo_contabil = '';
            logger.info('üí∞ Corrigido vl_bpo_contabil de "N√£o" para vazio');
        }
        
        // CORRE√á√ÉO 4: HONOR√ÅRIO TOTAL VAZIO
        // Se honorario_mensal_total est√° vazio mas h√° valores BPO, calcular
        if (!fixed.honorario_mensal_total && fixed.vl_bpo_rh) {
            // Usar o valor do BPO RH como total por enquanto
            fixed.honorario_mensal_total = fixed.vl_bpo_rh;
            logger.info(`üí∞ Honor√°rio total definido como: ${fixed.vl_bpo_rh}`);
        }
        
        return fixed;
    }

    // Fun√ß√£o para buscar dados da API
    async fetchGroupData(groupName) {
        try {
            // Importa o servi√ßo de busca por grupo diretamente (interno)
            const groupSearchService = require('./group-search.service');
            
            logger.info(`Buscando dados do grupo ${groupName} via servi√ßo interno`);
            const result = await groupSearchService.searchByGroup(groupName);
            
            if (result && result.success && result.empresas) {
                return result.empresas;
            } else {
                throw new Error(`Nenhuma empresa encontrada para o grupo: ${groupName}`);
            }
        } catch (error) {
            logger.error('Erro ao buscar dados do grupo:', error.message);
            throw error;
        }
    }

    // Fun√ß√£o para definir larguras fixas das colunas
    getFixedColumnWidths() {
        logger.info('üìê Aplicando larguras fixas das colunas...');
        
        const fixedWidths = [
            1.22,  // Coluna A (vazia)
            1.89,  // Coluna B (vazia)
            30,    // Coluna C (labels)
            50.11, // Coluna D
            54.78, // Coluna E  
            35,    // Coluna F
            14.89, // Coluna G
            1.22,  // Coluna H (vazia, mesmo tamanho da A)
            1.89   // Coluna I (vazia, mesmo tamanho da B)
        ];
        
        logger.info('üìä Larguras fixas:', fixedWidths.map((w, i) => `${String.fromCharCode(65 + i)}:${w}`).join(', '));
        logger.info('üôà Colunas J+ ser√£o ocultadas');
        
        return fixedWidths;
    }

    // Fun√ß√£o para configurar larguras das colunas fixas e ocultar colunas desnecess√°rias
    setupColumns(fixedWidths) {
        // Aplica larguras fixas at√© a coluna I
        const columns = fixedWidths.map(width => ({ width }));
        this.worksheet.columns = columns;
        
        // Oculta todas as colunas ap√≥s I (coluna 9, √≠ndice 8)
        for (let colIndex = 9; colIndex <= 50; colIndex++) { // Oculta J, K, L... at√© uma coluna alta
            const column = this.worksheet.getColumn(colIndex + 1);
            column.hidden = true;
        }
        
        this.worksheet.views = [
            { showGridLines: false }
        ];
        
        logger.info('‚úÖ Larguras fixas das colunas configuradas (A-I)');
        logger.info('üôà Colunas J+ ocultadas');
        logger.info('üî≤ Linhas de grade desativadas');
    }

    // Fun√ß√£o para adicionar dados √† estrutura interna (n√£o escreve na planilha ainda)
    addDataRow(data, styleType = 'default') {
        const paddedData = [...data];
        while (paddedData.length < 9) paddedData.push(''); // Apenas at√© coluna I (9 colunas)
        
        // Garantir que strings sejam tratadas como UTF-8 e corrigir caracteres espec√≠ficos
        const normalizedData = paddedData.map(item => {
            if (typeof item === 'string') {
                let text = item;
                
                // CORRE√á√ÉO DIRETA ANTES DA NORMALIZA√á√ÉO
                text = text.replace(/Certid√ßo/g, 'Certidao Negativa');
                text = text.replace(/Certid√∞√£o/g, 'Certidao Negativa');
                text = text.replace(/Certid√ßao/g, 'Certidao Negativa');
                
                // Normalizar string para UTF-8
                return text.normalize('NFD').normalize('NFC');
            }
            return item;
        });
        
        this.dataRows.push({
            data: normalizedData,
            styleType: styleType,
            rowNumber: this.currentRow
        });
        
        this.currentRow++;
        return this.dataRows.length - 1;
    }

    // Fun√ß√£o para adicionar linha vazia √† estrutura interna
    addEmptyDataRow() {
        return this.addDataRow(['', '', '', '', '', '', '', '', '']); // A at√© I (9 colunas)
    }

    // Fun√ß√£o para escrever todos os dados na planilha com formata√ß√£o
    writeDataToWorksheet() {
        logger.info('üìù Escrevendo dados na planilha com formata√ß√£o...');
        
        this.dataRows.forEach((rowData, index) => {
            const row = this.worksheet.addRow(rowData.data);
            
            row.eachCell((cell, colNumber) => {
                // Garantir que o valor da c√©lula seja UTF-8 correto
                if (typeof cell.value === 'string') {
                    let cellText = cell.value;
                    
                    // CORRE√á√ÉO DIRETA ANTES DA NORMALIZA√á√ÉO
                    cellText = cellText.replace(/Certid√ßo/g, 'Certidao Negativa');
                    cellText = cellText.replace(/Certid√∞√£o/g, 'Certidao Negativa');
                    cellText = cellText.replace(/Certid√ßao/g, 'Certidao Negativa');
                    
                    cell.value = cellText.normalize('NFD').normalize('NFC');
                }
                
                cell.font = this.styles[rowData.styleType].font;
                cell.alignment = this.styles[rowData.styleType].alignment;
                if (this.styles[rowData.styleType].fill) {
                    cell.fill = this.styles[rowData.styleType].fill;
                }
            });

            let isSectionHeader = false;
            if (rowData.data[2]) {
                const cellValue = String(rowData.data[2]).trim();
                isSectionHeader = ['Servi√ßos Contratados', 'Contato Principal', 'Entendimento do Neg√≥cio', 
                                 'Folha de Pagamento', 'Sistemas', 'Contabilidade e Fiscal', 'Honor√°rios e Cobran√ßa', 'Comercial'].includes(cellValue);
            }

            if (rowData.data[2]) {
                const cellValue = String(rowData.data[2]).trim();
                const isLabel = this.boldLabels.includes(cellValue) ||
                               cellValue.startsWith('Novo cliente -') ||
                               cellValue.startsWith('Empresas abertas') ||
                               cellValue.startsWith('Haver√° Cobran√ßa') ||
                               cellValue.startsWith('Vencimento:') ||
                               cellValue.startsWith('Faturar por:');
                
                if (isLabel) {
                    const cellC = row.getCell(3);
                    
                    if (isSectionHeader) {
                        for (let colNum = 3; colNum <= 9; colNum++) { // Apenas at√© coluna I
                            const cell = row.getCell(colNum);
                            cell.font = this.styles.sectionHeader.font;
                            cell.fill = this.styles.sectionHeader.fill;
                        }
                    } else if (cellValue.startsWith('Novo cliente -')) {
                        cellC.font = this.styles.mainHeader.font;
                        cellC.alignment = this.styles.mainHeader.alignment;
                    } else {
                        cellC.font = this.styles.bold.font;
                    }
                }
            }
            
            // ================== FORMATA√á√ÉO DE MOEDA ==================
            // Verifica se √© a linha de "Faturamento anual:" para aplicar o formato de moeda
            if (rowData.data[2] && String(rowData.data[2]).trim() === 'Faturamento anual:') {
                // Itera sobre as colunas D, E, F (√≠ndices 3, 4, 5)
                for (let colIndex = 3; colIndex <= 5; colIndex++) {
                    const cell = row.getCell(colIndex + 1);
                    
                    // Sempre aplicar alinhamento vertical central para valores monet√°rios
                    cell.alignment = { vertical: 'middle', horizontal: 'left' };
                    
                    // Aplica o formato apenas se o valor for um n√∫mero
                    if (typeof cell.value === 'number') {
                        cell.numFmt = CurrencyUtils.getExcelCurrencyFormat();
                    }
                }
            }

            // ================== FORMATA√á√ÉO DE HONOR√ÅRIOS ==================
            // Verifica se √© uma linha da se√ß√£o "Honor√°rios e Cobran√ßa"
            const honorariosLabels = [
                'BPO Cont√°bil:', 'BPO Fiscal:', 'BPO Folha:', 'BPO Financeiro:', 
                'BPO RH:', 'BPO Legal:', 'Total Mensal:'
            ];
            
            if (rowData.data[2] && honorariosLabels.includes(String(rowData.data[2]).trim())) {
                // Aplicar negrito no nome do servi√ßo (coluna C)
                const cellC = row.getCell(3);
                cellC.font = this.styles.bold.font;
                
                // Itera sobre as colunas D, E, F (√≠ndices 3, 4, 5)
                for (let colIndex = 3; colIndex <= 5; colIndex++) {
                    const cell = row.getCell(colIndex + 1);
                    
                    // Sempre aplicar alinhamento vertical central para valores monet√°rios
                    cell.alignment = { vertical: 'middle', horizontal: 'left' };
                    
                    // Aplica o formato apenas se o valor for um n√∫mero
                    if (typeof cell.value === 'number' && cell.value > 0) {
                        cell.numFmt = CurrencyUtils.getExcelCurrencyFormat();
                    }
                }
            }
            // ==========================================================

            for (let colIndex = 3; colIndex <= 5; colIndex++) {
                if (rowData.data[colIndex]) {
                    const cellValue = String(rowData.data[colIndex]).trim();
                    const isCompanyName = this.companyNames.includes(cellValue);
                    
                    if (isCompanyName && !isSectionHeader) {
                        const cell = row.getCell(colIndex + 1);
                        cell.font = this.styles.companyName.font;
                    }
                }
            }

            if (rowData.data[2] && String(rowData.data[2]).trim() === 'Site:') {
                for (let colIndex = 3; colIndex <= 5; colIndex++) {
                    if (rowData.data[colIndex] && String(rowData.data[colIndex]).trim().startsWith('http')) {
                        const cell = row.getCell(colIndex + 1);
                        const url = String(rowData.data[colIndex]).trim();
                        cell.value = {
                            text: url,
                            hyperlink: url
                        };
                        cell.font = {
                            ...this.styles.default.font,
                            color: { argb: 'FF000000' },
                            underline: true
                        };
                    }
                }
            }
            
            // ================== FORMATA√á√ÉO FINAL PARA HONOR√ÅRIOS ==================
            // Verifica√ß√£o espec√≠fica para garantir que "Honor√°rios e Cobran√ßa" tenha formata√ß√£o correta
            if (rowData.data[2] && String(rowData.data[2]).trim() === 'Honor√°rios e Cobran√ßa') {
                // Aplicar formata√ß√£o de section header em TODAS as colunas da linha
                for (let colNum = 3; colNum <= 9; colNum++) {
                    const cell = row.getCell(colNum);
                    if (cell.value) { // S√≥ formatar se tiver conte√∫do
                        cell.font = this.styles.sectionHeader.font;
                        cell.fill = this.styles.sectionHeader.fill;
                    }
                }
            }
        });

        this.applyMergedCells();
    }

    // Fun√ß√£o para adicionar imagem na linha 3
    async addImageToWorksheet() {
        try {
            // Verifica se o arquivo image.png existe no diret√≥rio
            const imagePath = path.join(__dirname, '../image.png');
            if (!fs.existsSync(imagePath)) {
                logger.info('‚ö†Ô∏è  Arquivo image.png n√£o encontrado. Pulando inser√ß√£o da imagem.');
                return;
            }

            logger.info('üìÅ Arquivo image.png encontrado, processando...');

            // L√™ o arquivo de imagem
            const imageBuffer = fs.readFileSync(imagePath);
            logger.info(`üìä Tamanho da imagem: ${imageBuffer.length} bytes`);
            
            // Adiciona a imagem ao workbook
            const imageId = this.workbook.addImage({
                buffer: imageBuffer,
                extension: 'png',
            });

            logger.info(`üÜî ID da imagem no workbook: ${imageId}`);

            // Ajusta a altura da linha 3 - menor altura vertical
            const row3 = this.worksheet.getRow(3);
            row3.height = 60; // Altura menor para n√£o ocupar muito espa√ßo vertical

            // Insere a imagem na linha 3 - come√ßando na coluna C
            this.worksheet.addImage(imageId, {
                tl: { col: 2, row: 2 }, // Top-left: coluna C (2), linha 3 (√≠ndice 2) 
                ext: { width: 500, height: 55 }, // Dimens√µes perfeitas para logo largo
                editAs: 'oneCell'
            });

            logger.info('üñºÔ∏è  Imagem inserida na linha 3 (C3)');
        } catch (error) {
            logger.info('‚ö†Ô∏è  Erro ao inserir imagem:', error.message);
            logger.info('Continuando sem a imagem...');
        }
    }

    applyMergedCells() {
        this.dataRows.forEach((rowData, index) => {
            if (rowData.data[2] && String(rowData.data[2]).startsWith('Novo cliente -')) {
                const excelRowNumber = index + 1;
                this.worksheet.mergeCells(`C${excelRowNumber}:I${excelRowNumber}`); // Mescla apenas at√© I
                
                const mergedCell = this.worksheet.getCell(`C${excelRowNumber}`);
                mergedCell.font = this.styles.mainHeader.font;
                mergedCell.alignment = this.styles.mainHeader.alignment;
            }
        });
    }

    addGroupHeader(groupName) {
        // Linha 1: Vazia (espa√ßamento)
        this.addEmptyDataRow();
        
        // Linha 2: Vazia (espa√ßamento) 
        this.addEmptyDataRow();
        
        // Linha 3: Ser√° reservada para a imagem (linha vazia aqui, imagem ser√° adicionada depois)
        this.addEmptyDataRow();
        
        // Linha 4: Novo cliente - agora come√ßando na coluna C
        this.addDataRow(['', '', `Novo cliente - ${groupName}`, '', '', '', '', '', '']);
        this.addEmptyDataRow();
    }

    chunkArray(array, size) {
        const chunks = [];
        for (let i = 0; i < array.length; i += size) {
            chunks.push(array.slice(i, i + size));
        }
        return chunks;
    }

    addCompanyBasicInfo(companies) {
¬† ¬† ¬† ¬† const chunks = this.chunkArray(companies, 3);
¬† ¬† ¬† ¬† 
¬† ¬† ¬† ¬† chunks.forEach(chunk => {
¬† ¬† ¬† ¬† ¬† ¬† const apelidoRow = ['', '', 'Apelido:'];
¬† ¬† ¬† ¬† ¬† ¬† chunk.forEach(company => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† apelidoRow.push(this.truncateCompanyName(company.nome_fantasia));
¬† ¬† ¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† ¬† ¬† while (apelidoRow.length < 9) apelidoRow.push('');
¬† ¬† ¬† ¬† ¬† ¬† this.addDataRow(apelidoRow);

¬† ¬† ¬† ¬† ¬† ¬† const codigoRow = ['', '', 'C√≥digo no sistema Dom√≠nio:'];
¬† ¬† ¬† ¬† ¬† ¬† chunk.forEach(company => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† codigoRow.push(this.convertToNumber(company.codigo, ''));
¬† ¬† ¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† ¬† ¬† while (codigoRow.length < 9) codigoRow.push('');
¬† ¬† ¬† ¬† ¬† ¬† this.addDataRow(codigoRow);

¬† ¬† ¬† ¬† ¬† ¬† const razaoRow = ['', '', 'Raz√£o Social:'];
¬† ¬† ¬† ¬† ¬† ¬† chunk.forEach(company => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† razaoRow.push(company.razao_social || '');
¬† ¬† ¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† ¬† ¬† while (razaoRow.length < 9) razaoRow.push('');
¬† ¬† ¬† ¬† ¬† ¬† this.addDataRow(razaoRow);

¬† ¬† ¬† ¬† ¬† ¬† const cnpjRow = ['', '', 'CNPJ:'];
¬† ¬† ¬† ¬† ¬† ¬† chunk.forEach(company => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† cnpjRow.push(company.cnpj || '');
¬† ¬† ¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† ¬† ¬† while (cnpjRow.length < 9) cnpjRow.push('');
¬† ¬† ¬† ¬† ¬† ¬† this.addDataRow(cnpjRow);

            // ==================================================================
¬† ¬† ¬† ¬† ¬† ¬† // AQUI COME√áA A L√ìGICA ATUALIZADA PARA "VIG√äNCIA INICIAL"
            // ==================================================================
¬† ¬† ¬† ¬† ¬† ¬† const vigenciaRow = ['', '', 'Vig√™ncia Inicial:'];
¬† ¬† ¬† ¬† ¬† ¬† chunk.forEach(company => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† let dataInicio;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const dateStringFromApi = company.inicio_contrato; // Ex: "2025-01-09"

                if (dateStringFromApi && dateStringFromApi.trim()) {
                    const dateStr = dateStringFromApi.trim();
                    
                    // FORMATO 1: DD/MM/YY (ex: "22/09/25")
                    if (dateStr.includes('/')) {
                        const parts = dateStr.split('/');
                        if (parts.length === 3) {
                            const day = parts[0];
                            const month = parts[1];
                            let year = parts[2];
                            
                            // Se ano tem 2 d√≠gitos, assumir 20XX
                            if (year.length === 2) {
                                year = '20' + year;
                            }
                            
                            // Formato ISO: YYYY-MM-DD
                            const isoDateString = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}T00:00:00`;
                            dataInicio = new Date(isoDateString);
                            logger.info(`üìÖ Data DD/MM/YY: "${dateStr}" ‚Üí ${isoDateString}`);
                        }
                    }
                    // FORMATO 2: YYYY-MM-DD (ex: "2025-01-10") 
                    else if (dateStr.includes('-')) {
                        const parts = dateStr.split('-');
                        if (parts.length === 3) {
                            const year = parts[0];
                            const month = parts[1];
                            const day = parts[2];
                            
                            const isoDateString = `${year}-${month}-${day}T00:00:00`;
                            dataInicio = new Date(isoDateString);
                            logger.info(`üìÖ Data YYYY-MM-DD: "${dateStr}" ‚Üí ${isoDateString}`);
                        }
                    }
                    else {
                        dataInicio = new Date(dateStr);
                        logger.info(`üìÖ Data formato direto: "${dateStr}"`);
                    }
                } else {
                    // Se n√£o houver data, usa a data atual como padr√£o
                    dataInicio = new Date();
                    logger.info(`üìÖ Sem data de in√≠cio, usando atual para ${company.nome_fantasia}`);
                }¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // Verifica se a data √© v√°lida antes de formatar
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (dataInicio && !isNaN(dataInicio)) {
                    // NOVA FORMATA√á√ÉO: 'set/25'
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const meses = ['jan', 'fev', 'mar', 'abr', 'mai', 'jun', 'jul', 'ago', 'set', 'out', 'nov', 'dez'];
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const mesAbreviado = meses[dataInicio.getMonth()];
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const anoCurto = String(dataInicio.getFullYear()).slice(-2);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† vigenciaRow.push(`${mesAbreviado}/${anoCurto}`);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† } else {
                    
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† vigenciaRow.push(''); // Caso a data da API seja inv√°lida
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† });
¬† ¬† ¬†Hello. OK. I. **** Are they all still alive? King series has been. He definitely Angel ago. Who is the Musica? Think about the human biology. FT History was our physical tutorials of work at each table was in a special point. I. They got the subway cayenne.  ¬† ¬† ¬† while (vigenciaRow.length < 9) vigenciaRow.push('');
¬† ¬† ¬† ¬† ¬† ¬† this.addDataRow(vigenciaRow);
            // ==================================================================
            // FIM DA L√ìGICA ATUALIZADA
            // ==================================================================

¬† ¬† ¬† ¬† ¬† ¬† const siteRow = ['', '', 'Site:'];
¬† ¬† ¬† ¬† ¬† ¬† chunk.forEach(company => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† siteRow.push(company.link_do_site || '');
¬† ¬† ¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† ¬† ¬† while (siteRow.length < 9) siteRow.push('');
¬† ¬† ¬† ¬† ¬† ¬† this.addDataRow(siteRow);

¬† ¬† ¬† ¬† ¬† ¬† const planoRow = ['', '', 'Plano Contratado:'];
¬† ¬† ¬† ¬† ¬† ¬† chunk.forEach(company => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† planoRow.push(company.plano_contratado || '');
¬† ¬† ¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† ¬† ¬† while (planoRow.length < 9) planoRow.push('');
¬† ¬† ¬† ¬† ¬† ¬† this.addDataRow(planoRow);

¬† ¬† ¬† ¬† ¬† ¬† const slaRow = ['', '', 'SLA Para Retorno:'];
¬† ¬† ¬† ¬† ¬† ¬† chunk.forEach(company => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† slaRow.push(company.sla || '');
¬† ¬† ¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† ¬† ¬† while (slaRow.length < 9) slaRow.push('');
¬† ¬† ¬† ¬† ¬† ¬† this.addDataRow(slaRow);

¬† ¬† ¬† ¬† ¬† ¬† this.addEmptyDataRow();
¬† ¬† ¬† ¬† });
¬† ¬† }

    addContractedServices(companies) {
        this.addDataRow(['', '', 'Servi√ßos Contratados', '', '', '', '', '', '']);

        // Mapeamento de todos os servi√ßos dispon√≠veis
        const servicosDisponiveis = [
            { campo: 'bpo_contabil', nome: 'BPO Cont√°bil' },
            { campo: 'bpo_fiscal', nome: 'BPO Fiscal' },
            { campo: 'bpo_folha', nome: 'BPO Folha' },
            { campo: 'bpo_financeiro', nome: 'BPO Financeiro' },
            { campo: 'bpo_rh', nome: 'BPO RH' },
            { campo: 'bpo_cnd', nome: 'Certid√µes Negativas' }
        ];

        // Filtra apenas os servi√ßos contratados (que t√™m "Sim") e numera sequencialmente
        const servicosContratados = [];
        let numeroServico = 1;

        servicosDisponiveis.forEach(servico => {
            if (companies.some(c => c[servico.campo] === 'Sim')) {
                servicosContratados.push(['', '', `Servi√ßo ${numeroServico}:`, servico.nome, '', '', '', '', '']);
                numeroServico++;
                logger.info(`üìã Servi√ßo contratado: ${servico.nome}`);
            }
        });

        // Adiciona os servi√ßos contratados √† planilha
        servicosContratados.forEach(servico => {
            this.addDataRow(servico);
        });

        // Se nenhum servi√ßo foi contratado, adiciona uma linha indicando isso
        if (servicosContratados.length === 0) {
            this.addDataRow(['', '', 'Nenhum servi√ßo contratado', '', '', '', '', '', '']);
        }

        this.addEmptyDataRow();
    }

    addMainContact(companies) {
        const firstCompany = companies[0];
        
        // Os dados j√° foram corrigidos na normaliza√ß√£o - usar diretamente
        const nome = firstCompany.contato_principal_nome || '';
        const cargo = firstCompany.contato_principal_cargo || '';
        const email = firstCompany.contato_principal_email || '';
        const celular = firstCompany.contato_principal_celular || '';
        
        this.addDataRow(['', '', 'Contato Principal', '', '', '', '', '', '']);
        this.addDataRow(['', '', 'Nome:', nome, '', '', '', '', '']);
        this.addDataRow(['', '', 'Cargo:', cargo, '', '', '', '', '']);
        this.addDataRow(['', '', 'E-mail:', email, '', '', '', '', '']);
        this.addDataRow(['', '', 'Celular:', celular, '', '', '', '', '']);
        this.addEmptyDataRow();
    }

    // Fun√ß√£o para adicionar entendimento do neg√≥cio - VERS√ÉO CORRIGIDA
    addBusinessUnderstanding(companies) {
        const chunks = this.chunkArray(companies, 3);
        
        chunks.forEach(chunk => {
            const headerRow = ['', '', 'Entendimento do Neg√≥cio'];
            chunk.forEach(company => {
                headerRow.push(this.truncateCompanyName(company.nome_fantasia));
            });
            while (headerRow.length < 9) headerRow.push('');
            this.addDataRow(headerRow);

            // ================== L√ìGICA DE FATURAMENTO CORRIGIDA ==================
            // Faturamento anual
            const faturamentoRow = ['', '', 'Faturamento anual:'];
            chunk.forEach(company => {
                const faturamentoString = company.faturamento_anual;
                
                if (typeof faturamentoString === 'string' && faturamentoString.trim() !== '') {
                    // Remove "R$" e espa√ßos
                    let valor = faturamentoString.replace(/R\$|\s/g, '');
                    
                    // Detecta o formato da moeda
                    let valorNumerico;
                    
                    // Formato brasileiro: R$ 3.500.000,00 (ponto = milhares, v√≠rgula = decimal)
                    if (valor.includes(',') && valor.lastIndexOf(',') > valor.lastIndexOf('.')) {
                        // Remove pontos (separadores de milhares) e substitui v√≠rgula por ponto
                        valorNumerico = parseFloat(valor.replace(/\./g, '').replace(',', '.'));
                        logger.info(`üí∞ Formato brasileiro detectado: "${faturamentoString}" ‚Üí ${valorNumerico}`);
                    }
                    // Formato americano: R$ 3,500,000.00 (v√≠rgula = milhares, ponto = decimal)
                    else if (valor.includes('.') && valor.lastIndexOf('.') > valor.lastIndexOf(',')) {
                        // Remove v√≠rgulas (separadores de milhares), mant√©m o ponto decimal
                        valorNumerico = parseFloat(valor.replace(/,/g, ''));
                        logger.info(`üí∞ Formato americano detectado: "${faturamentoString}" ‚Üí ${valorNumerico}`);
                    }
                    // Apenas n√∫meros com ponto (formato americano simples)
                    else if (valor.includes('.') && !valor.includes(',')) {
                        valorNumerico = parseFloat(valor);
                        logger.info(`üí∞ Formato americano simples: "${faturamentoString}" ‚Üí ${valorNumerico}`);
                    }
                    // Apenas n√∫meros com v√≠rgula (formato brasileiro simples)
                    else if (valor.includes(',') && !valor.includes('.')) {
                        valorNumerico = parseFloat(valor.replace(',', '.'));
                        logger.info(`üí∞ Formato brasileiro simples: "${faturamentoString}" ‚Üí ${valorNumerico}`);
                    }
                    // Apenas n√∫meros inteiros
                    else {
                        valorNumerico = parseFloat(valor);
                        logger.info(`üí∞ Formato num√©rico puro: "${faturamentoString}" ‚Üí ${valorNumerico}`);
                    }

                    if (!isNaN(valorNumerico) && valorNumerico > 0) {
                        // Adiciona o N√öMERO puro. A formata√ß√£o ser√° feita na escrita da planilha.
                        faturamentoRow.push(valorNumerico);
                    } else {
                        faturamentoRow.push('Sem Faturamento');
                        logger.info(`‚ùå Erro no faturamento: "${faturamentoString}" ‚Üí NaN`);
                    }
                } else {
                    faturamentoRow.push('Sem Faturamento');
                }
            });
            while (faturamentoRow.length < 9) faturamentoRow.push('');
            this.addDataRow(faturamentoRow);
            // ======================================================================

            const fields = [
                { label: 'Regime Tribut√°rio:', field: 'regime_tributario_atual', default: '' },
                { label: 'NF de Entrada:', field: 'nf_entradas', default: 0, isNumeric: true },
                { label: 'NF de Sa√≠da:', field: 'nf_saidas', default: 0, isNumeric: true },
                { label: 'CT-es de Entrada:', field: 'ctes_entrada', default: 0, isNumeric: true },
                { label: 'CT-es de Sa√≠da:', field: 'ctes_saida', default: 0, isNumeric: true },
                { label: 'NF de Prestados:', field: 'nf_servicos_prestados', default: 0, isNumeric: true },
                { label: 'NF de Tomados:', field: 'servicos_tomados', default: 0, isNumeric: true },
                { label: 'Funcion√°rios PJ:', field: 'nf_pjs', default: 0, isNumeric: true },
                { label: 'Centros de Custo:', field: 'centro_custo_quantidade', default: 0, isNumeric: true }
            ];

            fields.forEach(({ label, field, default: defaultValue, isNumeric }) => {
                const row = ['', '', label];
                chunk.forEach(company => {
                    if (isNumeric) {
                        row.push(this.convertToNumber(company[field], defaultValue));
                    } else {
                        row.push(company[field] || defaultValue);
                    }
                });
                while (row.length < 9) row.push('');
                this.addDataRow(row);
            });

            this.addEmptyDataRow();
        });
    }

    addPayroll(companies) {
        const chunks = this.chunkArray(companies, 3);
        
        chunks.forEach(chunk => {
            const headerRow = ['', '', 'Folha de Pagamento'];
            chunk.forEach(company => {
                headerRow.push(this.truncateCompanyName(company.nome_fantasia));
            });
            while (headerRow.length < 9) headerRow.push('');
            this.addDataRow(headerRow);

            const fields = [
                { label: 'Funcion√°rios CLT:', field: 'colab_clt', isNumeric: true },
                { label: 'Pr√≥-Labore:', field: 'pro_labore', isNumeric: true },
                { label: 'Estagi√°rios:', field: 'estagiarios', isNumeric: true },
                { label: 'Aprendizes:', field: 'aprendizes', isNumeric: true },
                { label: 'Aut√¥nomos - RPA:', field: 'rpa', isNumeric: true },
                { label: 'Dom√©sticas CLT:', field: 'domesticas_clt', isNumeric: true }
            ];

            fields.forEach(({ label, field, isNumeric }) => {
                const row = ['', '', label];
                chunk.forEach(company => {
                    if (isNumeric) {
                        row.push(this.convertToNumber(company[field], 0));
                    } else {
                        row.push(company[field] || 0);
                    }
                });
                while (row.length < 9) row.push('');
                this.addDataRow(row);
            });

            this.addEmptyDataRow();
        });
    }

    addSystemsInfo(companies) {
    // Passo 1: Coletar os valores de TODAS as empresas para os TR√äS campos.
    const contabeis = [...new Set(companies.map(c => c.sistema_contabil).filter(Boolean))];
    const folhas = [...new Set(companies.map(c => c.sistema_folha).filter(Boolean))];
    const fiscais = [...new Set(companies.map(c => c.sistema_fiscal).filter(Boolean))];
    const financeiros = [...new Set(companies.map(c => c.sistema_financeiro).filter(Boolean))];

    // Junta todos os sistemas encontrados em um √∫nico array para an√°lise.
    const todosOsSistemas = [...contabeis, ...folhas, ...fiscais, ...financeiros];

    // Passo 2: Descobrir quantos sistemas √öNICOS existem no total.
    const sistemasUnicosNoGeral = [...new Set(todosOsSistemas)];

    this.addEmptyDataRow();
    this.addDataRow(['', '', 'Sistemas', '', '', '', '', '', '']);

    // Passo 3: L√≥gica de decis√£o
    // SE s√≥ existe 1 sistema √∫nico para todas as √°reas (Cont√°bil, Folha, Fiscal)...
    if (sistemasUnicosNoGeral.length === 1) {
        // ...ent√£o consolidamos a exibi√ß√£o.
        const nomeDoSistema = sistemasUnicosNoGeral[0];
        const labels = [];

        if (contabeis.length > 0) labels.push('Cont√°bil');
        if (folhas.length > 0) labels.push('Folha');
        if (fiscais.length > 0) labels.push('Fiscal');
        if (financeiros.length > 0) labels.push('Financeiro');  
        
        // Formata o label de forma inteligente (ex: "Cont√°bil e Fiscal" ou "Cont√°bil, Folha e Fiscal")
        let finalLabel = '';
        if (labels.length > 1) {
            finalLabel = labels.slice(0, -1).join(', ') + ' e ' + labels.slice(-1);
        } else {
            finalLabel = labels.join('');
        }

        this.addDataRow(['', '', `${finalLabel}:`, nomeDoSistema, '', '', '', '', '']);

    } else {
        // SE os sistemas s√£o diferentes (ou n√£o h√° nenhum), mostramos em linhas separadas.
        const textoContabil = contabeis.join(', ');
        const textoFolha = folhas.join(', ');
        const textoFiscal = fiscais.join(', ');
        const textoFinanceiro = financeiros.join(', ');

        if (textoFinanceiro) {
            this.addDataRow(['', '', 'Financeiro:', textoFinanceiro, '', '', '', '', '']);
        }

        if (textoContabil) {
            this.addDataRow(['', '', 'Cont√°bil:', textoContabil, '', '', '', '', '']);
        }
        if (textoFolha) {
            this.addDataRow(['', '', 'Folha de Pagamento:', textoFolha, '', '', '', '', '']);
        }
        if (textoFiscal) {
            this.addDataRow(['', '', 'Fiscal:', textoFiscal, '', '', '', '', '']);
        }
    }

    this.addEmptyDataRow();
}

    addAccountingInfo(companies) {
        const chunks = this.chunkArray(companies, 3);
        
        chunks.forEach(chunk => {
            const headerRow = ['', '', 'Contabilidade e Fiscal'];
            chunk.forEach(company => {
                headerRow.push(this.truncateCompanyName(company.nome_fantasia));
            });
            while (headerRow.length < 9) headerRow.push('');
            this.addDataRow(headerRow);

            const deadlineRow = ['', '', 'Deadline:'];
            chunk.forEach(company => {
                // Monta deadline din√¢mico baseado nos campos da API
                // Monta deadline din√¢mico baseado nos campos da API
                const deadlineParts = [];

                if (company.deadline_util_corrente) {
                    deadlineParts.push(company.deadline_util_corrente);
                }
                if (company.deadline_periodicidade) {
                    deadlineParts.push(company.deadline_periodicidade);
                }
                if (company.deadline_dia) {
                    deadlineParts.push(`Dia ${company.deadline_dia}`);
                }

                // Junta as partes que existem com ", "
                const deadline = deadlineParts.join(', '); 
                deadlineRow.push(deadline);
            });
            while (deadlineRow.length < 9) deadlineRow.push('');
            this.addDataRow(deadlineRow);

            const cnaeRow = ['', '', 'CNAE:'];
            chunk.forEach(company => {
                cnaeRow.push(company.atividade_especialidade || '');
            });
            while (cnaeRow.length < 9) cnaeRow.push('');
            this.addDataRow(cnaeRow);

            this.addEmptyDataRow();
        });
    }

    addCommercialInfo(companies) {
    const firstCompany = companies[0];
    
    // Empresas abertas pela Go Further - agora vem da API
    this.addDataRow(['', '', 'Empresas abertas pela Go Further?', '', firstCompany.empresa_aberta_go || '', '', '', '', '']);
    this.addEmptyDataRow();
    
    // Cobran√ßa de Implanta√ß√£o - agora vem da API
    this.addDataRow(['', '', 'Haver√° Cobran√ßa de Implanta√ß√£o:', '', firstCompany.implantacao || '', '', '', '', '']);
    this.addDataRow(['', '', 'Vencimento:', '', firstCompany.vencimento_implantacao || '', '', '', '', '']);
    this.addEmptyDataRow();
    
    this.addDataRow(['', '', 'Faturar por:', '', '', '', '', '', '']);
    
    // Mapeamento completo de todos os 6 servi√ßos BPO
    const servicosFaturamento = [
        { 
            campo: 'bpo_contabil', 
            nome: 'Cont√°bil', 
            faturadoPor: 'bpo_contabil_faturado',
            default: ''
        },
        { 
            campo: 'bpo_fiscal', 
            nome: 'Fiscal', 
            faturadoPor: 'bpo_fiscal_faturado',
            default: ''
        },
        { 
            campo: 'bpo_folha', 
            nome: 'Folha', 
            faturadoPor: 'bpo_folha_faturado',
            default: ''
        },
        { 
            campo: 'bpo_financeiro', 
            nome: 'Financeiro', 
            faturadoPor: 'bpo_financeiro_faturado',
            default: ''
        },
        { 
            campo: 'bpo_rh', 
            nome: 'RH', 
            faturadoPor: 'bpo_rh_faturado',
            default: ''
        },
        { 
            campo: 'bpo_cnd', 
            nome: 'BPO Legal', 
            faturadoPor: 'bpo_legal_faturado', // Mapeia bpo_cnd para bpo_legal_faturado
            default: ''
        }
    ];

    // Processa cada servi√ßo se estiver contratado
    servicosFaturamento.forEach(servico => {
        // Verifica se alguma empresa tem o servi√ßo contratado
        if (companies.some(c => c[servico.campo] === 'Sim')) {
            // Pega o valor do campo faturado da API ou usa o default
            let faturadoPor = firstCompany[servico.faturadoPor];
            
            // Se o campo estiver vazio ou for null/undefined, usa o default (agora vazio)
            if (!faturadoPor || faturadoPor.trim() === '') {
                faturadoPor = servico.default;
                logger.info(`‚ö†Ô∏è  Campo ${servico.faturadoPor} vazio, usando default: vazio`);
            } else {
                logger.info(`‚úÖ Campo ${servico.faturadoPor} da API: ${faturadoPor}`);
            }
            
            this.addDataRow(['', '', servico.nome, '', faturadoPor, '', '', '', '']);
            logger.info(`üìã ${servico.nome} faturado por: ${faturadoPor}`);
        }
    });
    
    this.addEmptyDataRow();
    
    this.addDataRow(['', '', 'Comercial', '', '', '', '', '', '']);
    this.addDataRow(['', '', 'Closer:', firstCompany.closer || '', '', '', '', '', '']);
    this.addDataRow(['', '', 'Prospector:', firstCompany.prospector || '', '', '', '', '', '']);
    
    if (firstCompany.observacao_closer) {
        this.addDataRow(['', '', 'Obs Closer:', firstCompany.observacao_closer, '', '', '', '', '']);
    }
    
    if (firstCompany.observacoes_cadastro) {
        this.addDataRow(['', '', 'Obs:', firstCompany.observacoes_cadastro, '', '', '', '', '']);
    }
}

    // Nova se√ß√£o: Honor√°rios e Cobran√ßa
    addHonorarios(companies) {
        const chunks = this.chunkArray(companies, 3);
        
        chunks.forEach(chunk => {
            const headerRow = ['', '', 'Honor√°rios e Cobran√ßa'];
            chunk.forEach(company => {
                headerRow.push(this.truncateCompanyName(company.nome_fantasia));
            });
            while (headerRow.length < 9) headerRow.push('');
            this.addDataRow(headerRow);

            // Mapeamento de servi√ßos com valores
            const servicosHonorarios = [
                { campo: 'bpo_contabil', nome: 'BPO Cont√°bil', valorCampo: 'vl_bpo_contabil' },
                { campo: 'bpo_fiscal', nome: 'BPO Fiscal', valorCampo: 'vl_bpo_fiscal' },
                { campo: 'bpo_folha', nome: 'BPO Folha', valorCampo: 'vl_bpo_folha' },
                { campo: 'bpo_financeiro', nome: 'BPO Financeiro', valorCampo: 'vl_bpo_financeiro' },
                { campo: 'bpo_rh', nome: 'BPO RH', valorCampo: 'vl_bpo_rh' },
                { campo: 'bpo_cnd', nome: 'BPO Legal', valorCampo: 'vl_bpo_legal' }
            ];

            servicosHonorarios.forEach(servico => {
                // Verificar se alguma empresa do chunk tem o servi√ßo contratado
                const temServicoContratado = chunk.some(c => c[servico.campo] === 'Sim');
                
                if (temServicoContratado) {
                    const servicoRow = ['', '', servico.nome + ':'];
                    chunk.forEach(company => {
                        if (company[servico.campo] === 'Sim') {
                            const valor = CurrencyUtils.processForSpreadsheet(company[servico.valorCampo]);
                            servicoRow.push(valor);
                        } else {
                            servicoRow.push('R$ 0,00');
                        }
                    });
                    while (servicoRow.length < 9) servicoRow.push('');
                    this.addDataRow(servicoRow);
                }
            });

            // Total mensal
            const totalRow = ['', '', 'Total Mensal:'];
            chunk.forEach(company => {
                const total = CurrencyUtils.processForSpreadsheet(company.honorario_mensal_total);
                totalRow.push(total);
            });
            while (totalRow.length < 9) totalRow.push('');
            this.addDataRow(totalRow);

            this.addEmptyDataRow();
        });
    }

    async generateForGroup(groupName, companiesData = null) {
        try {
            logger.info(`Buscando dados para o grupo: ${groupName}`);
            
            // Se os dados das empresas foram fornecidos, usa eles; sen√£o busca da API
            let companies;
            if (companiesData && Array.isArray(companiesData) && companiesData.length > 0) {
                companies = companiesData.map(c => this.normalizeCompany(c));
                logger.info(`Usando dados fornecidos: ${companies.length} empresas (normalizadas)`);
            } else {
                const rawCompanies = await this.fetchGroupData(groupName);
                companies = Array.isArray(rawCompanies) ? rawCompanies.map(c => this.normalizeCompany(c)) : [];
                logger.info(`Dados buscados da API: ${companies ? companies.length : 0} empresas (normalizadas)`);
            }
            
            if (!companies || companies.length === 0) {
                throw new Error('Nenhuma empresa encontrada para o grupo especificado');
            }

            logger.info(`Encontradas ${companies.length} empresas. Gerando planilha...`);

            // Reset das vari√°veis para nova gera√ß√£o
            this.workbook = new ExcelJS.Workbook();
            this.worksheet = null;
            this.currentRow = 1;
            this.dataRows = [];

            this.companyNames = companies.map(company => this.truncateCompanyName(company.nome_fantasia)).filter(name => name.trim() !== '');
            logger.info(`üìã Nomes de empresas identificados: ${this.companyNames.length} (m√°x. ${this.maxCompanyNameLength} chars)`);

            logger.info('üìä Coletando todos os dados...');
            this.addGroupHeader(groupName);
            this.addCompanyBasicInfo(companies);
            this.addContractedServices(companies);
            this.addMainContact(companies);
            this.addBusinessUnderstanding(companies);
            this.addPayroll(companies);
            this.addSystemsInfo(companies);
            this.addAccountingInfo(companies);
            this.addCommercialInfo(companies);

            const fixedWidths = this.getFixedColumnWidths();

            this.worksheet = this.workbook.addWorksheet('Board');
            this.setupColumns(fixedWidths);

            this.writeDataToWorksheet();

            // Adiciona a imagem na linha 3
            await this.addImageToWorksheet();

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const fileName = `${groupName.replace(/\s+/g, '_')}_Ficha_Entrada_${timestamp}.xlsx`;
            const filePath = path.join(this.outputDir, fileName);
            
            logger.info('üíæ Salvando arquivo...');
            
            // Configurar options para garantir UTF-8
            await this.workbook.xlsx.writeFile(filePath);

            logger.info('‚úÖ Planilha gerada com sucesso!');
            logger.info(`üìÅ Arquivo: ${fileName}`);
            logger.info(`üìà Total de empresas: ${companies.length}`);
            logger.info(`üìÑ Total de linhas: ${this.currentRow}`);

            return {
                success: true,
                fileName: fileName,
                filePath: filePath,
                stats: {
                    companies: companies.length,
                    rows: this.currentRow
                }
            };

        } catch (error) {
            logger.error('Erro ao gerar planilha:', error.message);
            throw error;
        }
    }

    // Novo m√©todo para gerar planilhas por tipo
    async generateSpreadsheetByType(groupName, companiesData, tipo = 'entrada') {
        try {
            logger.info(`Gerando planilha tipo "${tipo}" para o grupo: ${groupName}`);
            
            let companies;
            if (companiesData && Array.isArray(companiesData) && companiesData.length > 0) {
                companies = companiesData.map(c => this.normalizeCompany(c));
                logger.info(`Usando dados fornecidos: ${companies.length} empresas (normalizadas)`);
            } else {
                const rawCompanies = await this.fetchGroupData(groupName);
                companies = Array.isArray(rawCompanies) ? rawCompanies.map(c => this.normalizeCompany(c)) : [];
                logger.info(`Dados buscados da API: ${companies ? companies.length : 0} empresas (normalizadas)`);
            }
            
            if (!companies || companies.length === 0) {
                throw new Error('Nenhuma empresa encontrada para o grupo especificado');
            }

            // Reset das vari√°veis para nova gera√ß√£o
            this.workbook = new ExcelJS.Workbook();
            this.worksheet = null;
            this.currentRow = 1;
            this.dataRows = [];

            this.companyNames = companies.map(company => this.truncateCompanyName(company.nome_fantasia)).filter(name => name.trim() !== '');
            logger.info(`üìã Nomes de empresas identificados: ${this.companyNames.length} (m√°x. ${this.maxCompanyNameLength} chars)`);

            logger.info(`üìä Coletando dados para planilha tipo: ${tipo}`);
            
            if (tipo === 'entrada') {
                // Planilha de entrada (original)
                this.addGroupHeader(groupName);
                this.addCompanyBasicInfo(companies);
                this.addContractedServices(companies);
                this.addMainContact(companies);
                this.addBusinessUnderstanding(companies);
                this.addPayroll(companies);
                this.addSystemsInfo(companies);
                this.addAccountingInfo(companies);
                this.addCommercialInfo(companies);
            } else if (tipo === 'cobranca') {
                // Planilha de honor√°rios e cobran√ßa
                this.addGroupHeader(groupName);
                this.addCompanyBasicInfo(companies);
                this.addContractedServices(companies);
                this.addMainContact(companies);
                this.addBusinessUnderstanding(companies);
                this.addPayroll(companies);
                this.addSystemsInfo(companies);
                this.addAccountingInfo(companies);
                this.addHonorarios(companies); // Nova se√ß√£o
                this.addCommercialInfo(companies);
            }

            const fixedWidths = this.getFixedColumnWidths();

            this.worksheet = this.workbook.addWorksheet('Board');
            this.setupColumns(fixedWidths);

            this.writeDataToWorksheet();

            // Adiciona a imagem na linha 3
            await this.addImageToWorksheet();

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const tipoSuffix = tipo === 'entrada' ? 'Entrada' : 'Cobranca';
            const fileName = `${groupName.replace(/\s+/g, '_')}_Ficha_${tipoSuffix}_${timestamp}.xlsx`;
            const filePath = path.join(this.outputDir, fileName);
            
            logger.info('üíæ Salvando arquivo...');
            
            // Configurar options para garantir UTF-8
            await this.workbook.xlsx.writeFile(filePath);

            logger.info(`‚úÖ Planilha tipo "${tipo}" gerada com sucesso!`);
            logger.info(`üìÅ Arquivo: ${fileName}`);
            logger.info(`üìà Total de empresas: ${companies.length}`);
            logger.info(`üìÑ Total de linhas: ${this.currentRow}`);

            return {
                success: true,
                fileName: fileName,
                filePath: filePath,
                tipo: tipo,
                stats: {
                    companies: companies.length,
                    rows: this.currentRow
                }
            };

        } catch (error) {
            logger.error(`Erro ao gerar planilha tipo "${tipo}":`, error.message);
            throw error;
        }
    }

    // M√©todo para manter compatibilidade com controller existente
    async generateXlsx(groupName, companies, tipoRelatorio = 'entrada', userId = null) {
        try {
            if (!groupName) {
                throw new Error('Nome do grupo √© obrigat√≥rio');
            }

            return await this.generateForGroup(groupName, companies);
        } catch (error) {
            logger.error('Erro no generateXlsx:', error);
            throw error;
        }
    }

    async downloadFile(fileName) {
        const filePath = path.join(this.outputDir, fileName);
        
        if (!fs.existsSync(filePath)) {
            throw new Error('Arquivo n√£o encontrado');
        }

        return {
            filePath: filePath,
            fileName: fileName,
            mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        };
    }

    listAvailableFiles() {
        try {
            if (!fs.existsSync(this.outputDir)) {
                return [];
            }

            const files = fs.readdirSync(this.outputDir)
                .filter(file => file.endsWith('.xlsx'))
                .map(file => {
                    const filePath = path.join(this.outputDir, file);
                    const stats = fs.statSync(filePath);
                    
                    return {
                        fileName: file,
                        downloadUrl: `/api/xlsx-generator/download/${file}`,
                        tamanho: stats.size,
                        criadoEm: stats.birthtime,
                        modificadoEm: stats.mtime
                    };
                })
                .sort((a, b) => new Date(b.criadoEm) - new Date(a.criadoEm));

            return files;
        } catch (error) {
            logger.error('Erro ao listar arquivos:', error);
            return [];
        }
    }

    // M√©todo para verificar se um arquivo existe
    fileExists(fileName) {
        try {
            const filePath = path.join(this.outputDir, fileName);
            return fs.existsSync(filePath);
        } catch (error) {
            logger.error('Erro ao verificar exist√™ncia do arquivo:', error);
            return false;
        }
    }

    // M√©todo para obter o caminho completo de um arquivo
    getFilePath(fileName) {
        return path.join(this.outputDir, fileName);
    }

    // M√©todo para limpeza de arquivos antigos
    cleanupOldFiles(maxAgeInDays = 7) {
        try {
            if (!fs.existsSync(this.outputDir)) {
                logger.info('Diret√≥rio de arquivos n√£o existe, nada para limpar');
                return { deleted: 0, total: 0 };
            }

            const files = fs.readdirSync(this.outputDir).filter(file => file.endsWith('.xlsx'));
            const now = Date.now();
            const maxAge = maxAgeInDays * 24 * 60 * 60 * 1000; // dias em millisegundos
            let deletedCount = 0;

            for (const file of files) {
                const filePath = path.join(this.outputDir, file);
                const stats = fs.statSync(filePath);
                
                if (now - stats.mtime.getTime() > maxAge) {
                    fs.unlinkSync(filePath);
                    deletedCount++;
                    logger.info(`Arquivo antigo removido: ${file}`);
                }
            }

            logger.info(`Limpeza conclu√≠da: ${deletedCount}/${files.length} arquivos removidos`);
            return { deleted: deletedCount, total: files.length };

        } catch (error) {
            logger.error('Erro na limpeza de arquivos:', error);
            return { deleted: 0, total: 0, error: error.message };
        }
    }

    // M√©todo para gerar dados da tabela em formato JSON para visualiza√ß√£o
    async generateTableData(groupName, companies) {
        try {
            if (!companies || companies.length === 0) {
                throw new Error('Nenhuma empresa encontrada para gerar dados da tabela');
            }

            // Estrutura de dados similar √† planilha
            const tableData = {
                header: {
                    title: `Ficha de Entrada - ${groupName}`,
                    empresas: companies.length,
                    geradoEm: new Date().toLocaleString('pt-BR')
                },
                companies: companies.map(company => ({
                    id: company.id || '',
                    nome_fantasia: company.nome_fantasia || '',
                    razao_social: company.razao_social || '',
                    cnpj: company.cnpj || '',
                    endereco: company.endereco || '',
                    telefone: company.telefone || '',
                    email: company.email || '',
                    responsavel: company.responsavel || '',
                    observacoes: company.observacoes || '',
                    grupo: company.grupo || groupName,
                    ativo: company.ativo || true
                })),
                summary: {
                    totalEmpresas: companies.length,
                    empresasAtivas: companies.filter(c => c.ativo !== false).length,
                    grupos: [...new Set(companies.map(c => c.grupo || groupName))]
                }
            };

            return tableData;

        } catch (error) {
            logger.error('Erro ao gerar dados da tabela:', error);
            throw error;
        }
    }
}

module.exports = new XlsxGeneratorService();
