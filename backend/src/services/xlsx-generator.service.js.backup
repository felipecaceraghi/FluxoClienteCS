const ExcelJS = require('exceljs');
const fs = require('fs');
const path = require('path');
const logger = require('../utils/logger');
const CurrencyUtils = require('../utils/currency');
const axios = require('axios');

class XlsxGeneratorService {
    constructor() {
        this.outputDir = path.join(__dirname, '../storage/generated-reports');
        this.ensureOutputDir();
        
        this.workbook = new ExcelJS.Workbook();
        
        // Configurar encoding explicitamente para UTF-8
        this.workbook.creator = 'FluxoClienteCS';
        this.workbook.lastModifiedBy = 'FluxoClienteCS';
        this.workbook.created = new Date();
        this.workbook.modified = new Date();
        this.workbook.calcProperties.fullCalcOnLoad = true;
        
        this.worksheet = null;
        this.currentRow = 1;
        this.dataRows = []; // Array para armazenar todas as linhas antes da escrita
        
        this.boldLabels = [
            'Apelido:', 'CÃ³digo no sistema DomÃ­nio:', 'RazÃ£o Social:', 'CNPJ:', 
            'VigÃªncia Inicial:', 'Site:', 'Plano Contratado:', 'SLA Para Retorno:',
            'ServiÃ§os Contratados', 'ServiÃ§o 1:', 'ServiÃ§o 2:', 'ServiÃ§o 3:', 'ServiÃ§o 4:', 'ServiÃ§o 5:', 'ServiÃ§o 6:',
            'Contato Principal', 'Nome:', 'Cargo:', 'E-mail:', 'Celular:',
            'Entendimento do NegÃ³cio', 'Faturamento anual:', 'Regime TributÃ¡rio:',
            'NF de Entrada:', 'NF de SaÃ­da:', 'CT-es de Entrada:', 'CT-es de SaÃ­da:',
            'NF de Prestados:', 'NF de Tomados:', 'FuncionÃ¡rios PJ:', 'Centros de Custo:',
            'Folha de Pagamento', 'FuncionÃ¡rios CLT:', 'PrÃ³-Labore:', 'EstagiÃ¡rios:',
            'Aprendizes:', 'AutÃ´nomos - RPA:', 'DomÃ©sticas CLT:', 'Sistemas',
            'ContÃ¡bil e Fiscal:', 'Contabilidade e Fiscal', 'Deadline:', 'CNAE:',
            'Comercial', 'Closer:', 'Prospector:', 'Obs Closer:', 'Obs:'
        ];

        // Definir estilos
        this.styles = {
            default: {
                font: { name: 'Calibri', size: 11 },
                alignment: { vertical: 'top', horizontal: 'left' }
            },
            bold: {
                font: { name: 'Calibri', size: 11, bold: true },
                alignment: { vertical: 'top', horizontal: 'left' }
            },
            sectionHeader: {
                font: { name: 'Calibri', size: 12, bold: true },
                alignment: { vertical: 'top', horizontal: 'left' },
                fill: { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFADDBDC' } }
            },
            mainHeader: {
                font: { name: 'Calibri', size: 25, bold: true, color: { argb: 'FF000000' } },
                alignment: { vertical: 'middle', horizontal: 'left' }
            },
            companyName: {
                font: { name: 'Calibri', size: 11, bold: true },
                alignment: { vertical: 'top', horizontal: 'left' }
            }
        };

        // Lista de nomes de empresas para aplicar negrito
        this.companyNames = [];
        
        // ConfiguraÃ§Ã£o de truncamento
        this.maxCompanyNameLength = 52;
    }

    ensureOutputDir() {
        if (!fs.existsSync(this.outputDir)) {
            fs.mkdirSync(this.outputDir, { recursive: true });
            logger.info('ğŸ“ DiretÃ³rio de relatÃ³rios criado', { path: this.outputDir });
        }
    }

    // FunÃ§Ã£o para converter valores para nÃºmeros nativos (evita "nÃºmero armazenado como texto")
    convertToNumber(value, defaultValue = 0) {
        if (value === null || value === undefined || value === '') {
            return defaultValue;
        }
        
        // Se jÃ¡ Ã© um nÃºmero, retorna como estÃ¡
        if (typeof value === 'number') {
            return value;
        }
        
        // Se Ã© string, tenta converter para nÃºmero
        if (typeof value === 'string') {
            const trimmed = value.trim();
            
            // Se string vazia apÃ³s trim, retorna default
            if (trimmed === '') {
                return defaultValue;
            }
            
            // Tenta converter para nÃºmero
            const parsed = parseFloat(trimmed);
            
            // Se conversÃ£o foi bem sucedida e Ã© um nÃºmero vÃ¡lido
            if (!isNaN(parsed) && isFinite(parsed)) {
                return parsed;
            }
        }
        
        // Se nÃ£o conseguiu converter, retorna o valor original
        return value;
    }

    truncateCompanyName(name) {
        if (!name) return '';
        const nameStr = String(name).trim();
        if (nameStr.length <= this.maxCompanyNameLength) {
            return nameStr;
        }
        const truncated = nameStr.substring(0, this.maxCompanyNameLength - 3) + '...';
        logger.info(`âœ‚ï¸ Nome truncado: "${nameStr}" â†’ "${truncated}" (${nameStr.length} â†’ ${truncated.length} chars)`);
        return truncated;
    }

    // FunÃ§Ã£o para truncar nome da empresa para o cabeÃ§alho (25 chars)
    truncateCompanyNameHeader(name) {
        if (!name) return '';
        const nameStr = String(name).trim();
        const maxLength = 25;
        if (nameStr.length <= maxLength) {
            return nameStr;
        }
        const truncated = nameStr.substring(0, maxLength - 3) + '...';
        logger.info(`âœ‚ï¸ Nome truncado para header: "${nameStr}" â†’ "${truncated}" (${nameStr.length} â†’ ${truncated.length} chars)`);
        return truncated;
    }

    // Normaliza diferentes formatos/versÃµes de payloads de empresa para o shape esperado
    normalizeCompany(raw) {
        if (!raw) return raw;

        // Mantemos todas as chaves originais e garantimos aliases para os campos crÃ­ticos
        const c = { ...raw };

        // Campos comuns/aliases
        c.nome_fantasia = raw.nome_fantasia || raw.nome || raw.name || raw.company || '';
        c.razao_social = raw.razao_social || raw.razao || raw.company_name || raw.razaoSocial || '';
        c.codigo = raw.codigo || raw.id || raw.code || raw.codigo_empresa || '';
        c.grupo = raw.grupo || raw.group || raw.groupName || raw.grupo_nome || '';
        c.inicio_contrato = raw.inicio_contrato || raw.data_inicio || raw.start_date || raw.inicio || raw.inicioContrato || null;
        c.cnpj = raw.cnpj || raw.cpf || raw.documento || '';
        c.faturamento_anual = raw.faturamento_anual || raw.faturamento || raw.revenue || '';

        // CORREÃ‡ÃƒO INTELIGENTE DE DADOS DESALINHADOS
        c = this.fixDataMisalignment(c);

        // Keep originals for any other property; return normalized object
        return c;
    }

    // FunÃ§Ã£o para corrigir dados desalinhados da API
    fixDataMisalignment(company) {
        const fixed = { ...company };
        
        // CORREÃ‡ÃƒO 1: CONTATOS DESALINHADOS
        const nome = company.contato_principal_nome || '';
        const cargo = company.contato_principal_cargo || '';
        const email = company.contato_principal_email || '';
        const celular = company.contato_principal_celular || '';
        
        // Detectar deslocamento nos contatos
        if (!nome.trim() && cargo.trim() && !cargo.includes('@')) {
            logger.info('ğŸ”§ Corrigindo desalinhamento de contatos para:', company.nome_fantasia);
            
            // Contatos deslocados: cargoâ†’nome, emailâ†’cargo, celularâ†’email
            fixed.contato_principal_nome = cargo;
            fixed.contato_principal_cargo = email;
            fixed.contato_principal_email = celular;
            
            // Buscar celular no plano_contratado
            const plano = company.plano_contratado || '';
            if (plano.includes('+55') || plano.match(/\(\d{2}\)|\d{4,5}-?\d{4}/)) {
                fixed.contato_principal_celular = plano;
                logger.info(`ğŸ“± Celular movido de plano_contratado: "${plano}"`);
                
                // CORREÃ‡ÃƒO 2: PLANO/SLA DESALINHADOS
                // Se celular estava em plano_contratado, plano real estÃ¡ em sla
                const slaOriginal = company.sla || '';
                fixed.plano_contratado = slaOriginal;
                fixed.sla = 'Conforme necessidade'; // SLA padrÃ£o
                logger.info(`ğŸ“‹ Plano movido de sla: "${slaOriginal}"`);
            } else {
                fixed.contato_principal_celular = '';
            }
        }
        
        // CORREÃ‡ÃƒO 2.1: PLANO/SLA SEMPRE VERIFICAR (mesmo sem deslocamento de contatos)
        const planoAtual = fixed.plano_contratado || '';
        const slaAtual = fixed.sla || '';
        
        // Se plano tem formato de telefone, mas SLA tem texto de plano
        if (planoAtual.includes('+55') && slaAtual && !slaAtual.includes('+55')) {
            const temp = fixed.plano_contratado;
            fixed.plano_contratado = fixed.sla;
            fixed.sla = 'Conforme necessidade';
            logger.info(`ğŸ”„ Corrigido plano/SLA: "${temp}" â†” "${fixed.plano_contratado}"`);
        }
        
        // CORREÃ‡ÃƒO 2.2: IMPLANTAÃ‡ÃƒO DESALINHADA
        const implantacao = company.implantacao || '';
        const vencimentoImplantacao = company.vencimento_implantacao || '';
        
        // Se implantaÃ§Ã£o estÃ¡ vazia mas vencimento tem "NÃ£o"
        if (!implantacao.trim() && vencimentoImplantacao === 'NÃ£o') {
            fixed.implantacao = 'NÃ£o';
            fixed.vencimento_implantacao = '';
            logger.info(`ğŸ“… Corrigido implantaÃ§Ã£o: vazia â†’ "NÃ£o"`);
        }
        
        // CORREÃ‡ÃƒO 3: VALORES BPO INCONSISTENTES
        // Se vl_bpo_contabil tem string "NÃ£o" em vez de valor, corrigir
        if (fixed.vl_bpo_contabil === 'NÃ£o') {
            fixed.vl_bpo_contabil = '';
            logger.info('ğŸ’° Corrigido vl_bpo_contabil de "NÃ£o" para vazio');
        }
        
        // CORREÃ‡ÃƒO 4: HONORÃRIO TOTAL VAZIO
        // Se honorario_mensal_total estÃ¡ vazio mas hÃ¡ valores BPO, calcular
        if (!fixed.honorario_mensal_total && fixed.vl_bpo_rh) {
            // Usar o valor do BPO RH como total por enquanto
            fixed.honorario_mensal_total = fixed.vl_bpo_rh;
            logger.info(`ğŸ’° HonorÃ¡rio total definido como: ${fixed.vl_bpo_rh}`);
        }
        
        return fixed;
    }

    // FunÃ§Ã£o para buscar dados da API
    async fetchGroupData(groupName) {
        try {
            // Importa o serviÃ§o de busca por grupo diretamente (interno)
            const groupSearchService = require('./group-search.service');
            
            logger.info(`Buscando dados do grupo ${groupName} via serviÃ§o interno`);
            const result = await groupSearchService.searchByGroup(groupName);
            
            if (result && result.success && result.empresas) {
                return result.empresas;
            } else {
                throw new Error(`Nenhuma empresa encontrada para o grupo: ${groupName}`);
            }
        } catch (error) {
            logger.error('Erro ao buscar dados do grupo:', error.message);
            throw error;
        }
    }

    // FunÃ§Ã£o para definir larguras fixas das colunas
    getFixedColumnWidths() {
        logger.info('ğŸ“ Aplicando larguras fixas das colunas...');
        
        const fixedWidths = [
            1.22,  // Coluna A (vazia)
            1.89,  // Coluna B (vazia)
            30,    // Coluna C (labels)
            50.11, // Coluna D
            54.78, // Coluna E  
            35,    // Coluna F
            14.89, // Coluna G
            1.22,  // Coluna H (vazia, mesmo tamanho da A)
            1.89   // Coluna I (vazia, mesmo tamanho da B)
        ];
        
        logger.info('ğŸ“Š Larguras fixas:', fixedWidths.map((w, i) => `${String.fromCharCode(65 + i)}:${w}`).join(', '));
        logger.info('ğŸ™ˆ Colunas J+ serÃ£o ocultadas');
        
        return fixedWidths;
    }

    // FunÃ§Ã£o para configurar larguras das colunas fixas e ocultar colunas desnecessÃ¡rias
    setupColumns(fixedWidths) {
        // Aplica larguras fixas atÃ© a coluna I
        const columns = fixedWidths.map(width => ({ width }));
        this.worksheet.columns = columns;
        
        // Oculta todas as colunas apÃ³s I (coluna 9, Ã­ndice 8)
        for (let colIndex = 9; colIndex <= 50; colIndex++) { // Oculta J, K, L... atÃ© uma coluna alta
            const column = this.worksheet.getColumn(colIndex + 1);
            column.hidden = true;
        }
        
        this.worksheet.views = [
            { showGridLines: false }
        ];
        
        logger.info('âœ… Larguras fixas das colunas configuradas (A-I)');
        logger.info('ğŸ™ˆ Colunas J+ ocultadas');
        logger.info('ğŸ”² Linhas de grade desativadas');
    }

    // FunÃ§Ã£o para adicionar dados Ã  estrutura interna (nÃ£o escreve na planilha ainda)
    addDataRow(data, styleType = 'default') {
        const paddedData = [...data];
        while (paddedData.length < 9) paddedData.push(''); // Apenas atÃ© coluna I (9 colunas)
        
        // Garantir que strings sejam tratadas como UTF-8 e corrigir caracteres especÃ­ficos
        const normalizedData = paddedData.map(item => {
            if (typeof item === 'string') {
                let text = item;
                
                // CORREÃ‡ÃƒO DIRETA ANTES DA NORMALIZAÃ‡ÃƒO
                text = text.replace(/CertidÃ§o/g, 'Certidao Negativa');
                text = text.replace(/CertidÃ°Ã£o/g, 'Certidao Negativa');
                text = text.replace(/CertidÃ§ao/g, 'Certidao Negativa');
                
                // Normalizar string para UTF-8
                return text.normalize('NFD').normalize('NFC');
            }
            return item;
        });
        
        this.dataRows.push({
            data: normalizedData,
            styleType: styleType,
            rowNumber: this.currentRow
        });
        
        this.currentRow++;
        return this.dataRows.length - 1;
    }

    // FunÃ§Ã£o para adicionar linha vazia Ã  estrutura interna
    addEmptyDataRow() {
        return this.addDataRow(['', '', '', '', '', '', '', '', '']); // A atÃ© I (9 colunas)
    }

    // FunÃ§Ã£o para escrever todos os dados na planilha com formataÃ§Ã£o
    writeDataToWorksheet() {
        logger.info('ğŸ“ Escrevendo dados na planilha com formataÃ§Ã£o...');
        
        this.dataRows.forEach((rowData, index) => {
            const row = this.worksheet.addRow(rowData.data);
            
            row.eachCell((cell, colNumber) => {
                // Garantir que o valor da cÃ©lula seja UTF-8 correto
                if (typeof cell.value === 'string') {
                    let cellText = cell.value;
                    
                    // CORREÃ‡ÃƒO DIRETA ANTES DA NORMALIZAÃ‡ÃƒO
                    cellText = cellText.replace(/CertidÃ§o/g, 'Certidao Negativa');
                    cellText = cellText.replace(/CertidÃ°Ã£o/g, 'Certidao Negativa');
                    cellText = cellText.replace(/CertidÃ§ao/g, 'Certidao Negativa');
                    
                    cell.value = cellText.normalize('NFD').normalize('NFC');
                }
                
                cell.font = this.styles[rowData.styleType].font;
                cell.alignment = this.styles[rowData.styleType].alignment;
                if (this.styles[rowData.styleType].fill) {
                    cell.fill = this.styles[rowData.styleType].fill;
                }
            });

            let isSectionHeader = false;
            if (rowData.data[2]) {
                const cellValue = String(rowData.data[2]).trim();
                isSectionHeader = ['ServiÃ§os Contratados', 'Contato Principal', 'Entendimento do NegÃ³cio', 
                                 'Folha de Pagamento', 'Sistemas', 'Contabilidade e Fiscal', 'HonorÃ¡rios e CobranÃ§a', 'Comercial'].includes(cellValue);
            }

            if (rowData.data[2]) {
                const cellValue = String(rowData.data[2]).trim();
                const isLabel = this.boldLabels.includes(cellValue) ||
                               cellValue.startsWith('Novo cliente -') ||
                               cellValue.startsWith('Empresas abertas') ||
                               cellValue.startsWith('HaverÃ¡ CobranÃ§a') ||
                               cellValue.startsWith('Vencimento:') ||
                               cellValue.startsWith('Faturar por:');
                
                if (isLabel) {
                    const cellC = row.getCell(3);
                    
                    if (isSectionHeader) {
                        for (let colNum = 3; colNum <= 9; colNum++) { // Apenas atÃ© coluna I
                            const cell = row.getCell(colNum);
                            cell.font = this.styles.sectionHeader.font;
                            cell.fill = this.styles.sectionHeader.fill;
                        }
                    } else if (cellValue.startsWith('Novo cliente -')) {
                        cellC.font = this.styles.mainHeader.font;
                        cellC.alignment = this.styles.mainHeader.alignment;
                    } else {
                        cellC.font = this.styles.bold.font;
                    }
                }
            }
            
            // ================== FORMATAÃ‡ÃƒO DE MOEDA ==================
            // Verifica se Ã© a linha de "Faturamento anual:" para aplicar o formato de moeda
            if (rowData.data[2] && String(rowData.data[2]).trim() === 'Faturamento anual:') {
                // Itera sobre as colunas D, E, F (Ã­ndices 3, 4, 5)
                for (let colIndex = 3; colIndex <= 5; colIndex++) {
                    const cell = row.getCell(colIndex + 1);
                    
                    // Sempre aplicar alinhamento vertical central para valores monetÃ¡rios
                    cell.alignment = { vertical: 'middle', horizontal: 'left' };
                    
                    // Aplica o formato apenas se o valor for um nÃºmero
                    if (typeof cell.value === 'number') {
                        cell.numFmt = CurrencyUtils.getExcelCurrencyFormat();
                    }
                }
            }

            // ================== FORMATAÃ‡ÃƒO DE HONORÃRIOS ==================
            // Verifica se Ã© uma linha da seÃ§Ã£o "HonorÃ¡rios e CobranÃ§a"
            const honorariosLabels = [
                'BPO ContÃ¡bil:', 'BPO Fiscal:', 'BPO Folha:', 'BPO Financeiro:', 
                'BPO RH:', 'BPO Legal:', 'Total Mensal:'
            ];
            
            if (rowData.data[2] && honorariosLabels.includes(String(rowData.data[2]).trim())) {
                // Aplicar negrito no nome do serviÃ§o (coluna C)
                const cellC = row.getCell(3);
                cellC.font = this.styles.bold.font;
                
                // Itera sobre as colunas D, E, F (Ã­ndices 3, 4, 5)
                for (let colIndex = 3; colIndex <= 5; colIndex++) {
                    const cell = row.getCell(colIndex + 1);
                    
                    // Sempre aplicar alinhamento vertical central para valores monetÃ¡rios
                    cell.alignment = { vertical: 'middle', horizontal: 'left' };
                    
                    // Aplica o formato apenas se o valor for um nÃºmero
                    if (typeof cell.value === 'number' && cell.value > 0) {
                        cell.numFmt = CurrencyUtils.getExcelCurrencyFormat();
                    }
                }
            }
            // ==========================================================

            for (let colIndex = 3; colIndex <= 5; colIndex++) {
                if (rowData.data[colIndex]) {
                    const cellValue = String(rowData.data[colIndex]).trim();
                    const isCompanyName = this.companyNames.includes(cellValue);
                    
                    if (isCompanyName && !isSectionHeader) {
                        const cell = row.getCell(colIndex + 1);
                        cell.font = this.styles.companyName.font;
                    }
                }
            }

            if (rowData.data[2] && String(rowData.data[2]).trim() === 'Site:') {
                for (let colIndex = 3; colIndex <= 5; colIndex++) {
                    if (rowData.data[colIndex] && String(rowData.data[colIndex]).trim().startsWith('http')) {
                        const cell = row.getCell(colIndex + 1);
                        const url = String(rowData.data[colIndex]).trim();
                        cell.value = {
                            text: url,
                            hyperlink: url
                        };
                        cell.font = {
                            ...this.styles.default.font,
                            color: { argb: 'FF000000' },
                            underline: true
                        };
                    }
                }
            }
            
            // ================== FORMATAÃ‡ÃƒO FINAL PARA HONORÃRIOS ==================
            // VerificaÃ§Ã£o especÃ­fica para garantir que "HonorÃ¡rios e CobranÃ§a" tenha formataÃ§Ã£o correta
            if (rowData.data[2] && String(rowData.data[2]).trim() === 'HonorÃ¡rios e CobranÃ§a') {
                // Aplicar formataÃ§Ã£o de section header em TODAS as colunas da linha
                for (let colNum = 3; colNum <= 9; colNum++) {
                    const cell = row.getCell(colNum);
                    if (cell.value) { // SÃ³ formatar se tiver conteÃºdo
                        cell.font = this.styles.sectionHeader.font;
                        cell.fill = this.styles.sectionHeader.fill;
                    }
                }
            }
        });

        this.applyMergedCells();
    }

    // FunÃ§Ã£o para adicionar imagem na linha 3
    async addImageToWorksheet() {
        try {
            // Verifica se o arquivo image.png existe no diretÃ³rio
            const imagePath = path.join(__dirname, '../image.png');
            if (!fs.existsSync(imagePath)) {
                logger.info('âš ï¸  Arquivo image.png nÃ£o encontrado. Pulando inserÃ§Ã£o da imagem.');
                return;
            }

            logger.info('ğŸ“ Arquivo image.png encontrado, processando...');

            // LÃª o arquivo de imagem
            const imageBuffer = fs.readFileSync(imagePath);
            logger.info(`ğŸ“Š Tamanho da imagem: ${imageBuffer.length} bytes`);
            
            // Adiciona a imagem ao workbook
            const imageId = this.workbook.addImage({
                buffer: imageBuffer,
                extension: 'png',
            });

            logger.info(`ğŸ†” ID da imagem no workbook: ${imageId}`);

            // Ajusta a altura da linha 3 - menor altura vertical
            const row3 = this.worksheet.getRow(3);
            row3.height = 60; // Altura menor para nÃ£o ocupar muito espaÃ§o vertical

            // Insere a imagem na linha 3 - comeÃ§ando na coluna C
            this.worksheet.addImage(imageId, {
                tl: { col: 2, row: 2 }, // Top-left: coluna C (2), linha 3 (Ã­ndice 2) 
                ext: { width: 500, height: 55 }, // DimensÃµes perfeitas para logo largo
                editAs: 'oneCell'
            });

            logger.info('ğŸ–¼ï¸  Imagem inserida na linha 3 (C3)');
        } catch (error) {
            logger.info('âš ï¸  Erro ao inserir imagem:', error.message);
            logger.info('Continuando sem a imagem...');
        }
    }

    applyMergedCells() {
        this.dataRows.forEach((rowData, index) => {
            if (rowData.data[2] && String(rowData.data[2]).startsWith('Novo cliente -')) {
                const excelRowNumber = index + 1;
                this.worksheet.mergeCells(`C${excelRowNumber}:I${excelRowNumber}`); // Mescla apenas atÃ© I
                
                const mergedCell = this.worksheet.getCell(`C${excelRowNumber}`);
                mergedCell.font = this.styles.mainHeader.font;
                mergedCell.alignment = this.styles.mainHeader.alignment;
            }
        });
    }

    addGroupHeader(groupName) {
        // Linha 1: Vazia (espaÃ§amento)
        this.addEmptyDataRow();
        
        // Linha 2: Vazia (espaÃ§amento) 
        this.addEmptyDataRow();
        
        // Linha 3: SerÃ¡ reservada para a imagem (linha vazia aqui, imagem serÃ¡ adicionada depois)
        this.addEmptyDataRow();
        
        // Linha 4: Novo cliente - agora comeÃ§ando na coluna C
        this.addDataRow(['', '', `Novo cliente - ${groupName}`, '', '', '', '', '', '']);
        this.addEmptyDataRow();
    }

    chunkArray(array, size) {
        const chunks = [];
        for (let i = 0; i < array.length; i += size) {
            chunks.push(array.slice(i, i + size));
        }
        return chunks;
    }

    addCompanyBasicInfo(companies) {
Â  Â  Â  Â  const chunks = this.chunkArray(companies, 3);
Â  Â  Â  Â  
Â  Â  Â  Â  chunks.forEach(chunk => {
Â  Â  Â  Â  Â  Â  const apelidoRow = ['', '', 'Apelido:'];
Â  Â  Â  Â  Â  Â  chunk.forEach(company => {
Â  Â  Â  Â  Â  Â  Â  Â  apelidoRow.push(this.truncateCompanyName(company.nome_fantasia));
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  while (apelidoRow.length < 9) apelidoRow.push('');
Â  Â  Â  Â  Â  Â  this.addDataRow(apelidoRow);

Â  Â  Â  Â  Â  Â  const codigoRow = ['', '', 'CÃ³digo no sistema DomÃ­nio:'];
Â  Â  Â  Â  Â  Â  chunk.forEach(company => {
Â  Â  Â  Â  Â  Â  Â  Â  codigoRow.push(this.convertToNumber(company.codigo, ''));
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  while (codigoRow.length < 9) codigoRow.push('');
Â  Â  Â  Â  Â  Â  this.addDataRow(codigoRow);

Â  Â  Â  Â  Â  Â  const razaoRow = ['', '', 'RazÃ£o Social:'];
Â  Â  Â  Â  Â  Â  chunk.forEach(company => {
Â  Â  Â  Â  Â  Â  Â  Â  razaoRow.push(company.razao_social || '');
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  while (razaoRow.length < 9) razaoRow.push('');
Â  Â  Â  Â  Â  Â  this.addDataRow(razaoRow);

Â  Â  Â  Â  Â  Â  const cnpjRow = ['', '', 'CNPJ:'];
Â  Â  Â  Â  Â  Â  chunk.forEach(company => {
Â  Â  Â  Â  Â  Â  Â  Â  cnpjRow.push(company.cnpj || '');
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  while (cnpjRow.length < 9) cnpjRow.push('');
Â  Â  Â  Â  Â  Â  this.addDataRow(cnpjRow);

            // ==================================================================
Â  Â  Â  Â  Â  Â  // AQUI COMEÃ‡A A LÃ“GICA ATUALIZADA PARA "VIGÃŠNCIA INICIAL"
            // ==================================================================
Â  Â  Â  Â  Â  Â  const vigenciaRow = ['', '', 'VigÃªncia Inicial:'];
Â  Â  Â  Â  Â  Â  chunk.forEach(company => {
Â  Â  Â  Â  Â  Â  Â  Â  let dataInicio;
Â  Â  Â  Â  Â  Â  Â  Â  const dateStringFromApi = company.inicio_contrato; // Ex: "2025-01-09"

                if (dateStringFromApi && dateStringFromApi.trim()) {
                    const dateStr = dateStringFromApi.trim();
                    
                    // FORMATO 1: DD/MM/YY (ex: "22/09/25")
                    if (dateStr.includes('/')) {
                        const parts = dateStr.split('/');
                        if (parts.length === 3) {
                            const day = parts[0];
                            const month = parts[1];
                            let year = parts[2];
                            
                            // Se ano tem 2 dÃ­gitos, assumir 20XX
                            if (year.length === 2) {
                                year = '20' + year;
                            }
                            
                            // Formato ISO: YYYY-MM-DD
                            const isoDateString = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}T00:00:00`;
                            dataInicio = new Date(isoDateString);
                            logger.info(`ğŸ“… Data DD/MM/YY: "${dateStr}" â†’ ${isoDateString}`);
                        }
                    }
                    // FORMATO 2: YYYY-MM-DD (ex: "2025-01-10") 
                    else if (dateStr.includes('-')) {
                        const parts = dateStr.split('-');
                        if (parts.length === 3) {
                            const year = parts[0];
                            const month = parts[1];
                            const day = parts[2];
                            
                            const isoDateString = `${year}-${month}-${day}T00:00:00`;
                            dataInicio = new Date(isoDateString);
                            logger.info(`ğŸ“… Data YYYY-MM-DD: "${dateStr}" â†’ ${isoDateString}`);
                        }
                    }
                    else {
                        dataInicio = new Date(dateStr);
                        logger.info(`ğŸ“… Data formato direto: "${dateStr}"`);
                    }
                } else {
                    // Se nÃ£o houver data, usa a data atual como padrÃ£o
                    dataInicio = new Date();
                    logger.info(`ğŸ“… Sem data de inÃ­cio, usando atual para ${company.nome_fantasia}`);
                }Â  Â  Â  Â  Â  Â  Â  Â  // Verifica se a data Ã© vÃ¡lida antes de formatar
Â  Â  Â  Â  Â  Â  Â  Â  if (dataInicio && !isNaN(dataInicio)) {
                    // NOVA FORMATAÃ‡ÃƒO: 'set/25'
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const meses = ['jan', 'fev', 'mar', 'abr', 'mai', 'jun', 'jul', 'ago', 'set', 'out', 'nov', 'dez'];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const mesAbreviado = meses[dataInicio.getMonth()];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const anoCurto = String(dataInicio.getFullYear()).slice(-2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  vigenciaRow.push(`${mesAbreviado}/${anoCurto}`);
Â  Â  Â  Â  Â  Â  Â  Â  } else {
                    
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  vigenciaRow.push(''); // Caso a data da API seja invÃ¡lida
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  });
Â  Â  Â Hello. OK. I. **** Are they all still alive? King series has been. He definitely Angel ago. Who is the Musica? Think about the human biology. FT History was our physical tutorials of work at each table was in a special point. I. They got the subway cayenne.  Â  Â  Â  while (vigenciaRow.length < 9) vigenciaRow.push('');
Â  Â  Â  Â  Â  Â  this.addDataRow(vigenciaRow);
            // ==================================================================
            // FIM DA LÃ“GICA ATUALIZADA
            // ==================================================================

Â  Â  Â  Â  Â  Â  const siteRow = ['', '', 'Site:'];
Â  Â  Â  Â  Â  Â  chunk.forEach(company => {
Â  Â  Â  Â  Â  Â  Â  Â  siteRow.push(company.link_do_site || '');
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  while (siteRow.length < 9) siteRow.push('');
Â  Â  Â  Â  Â  Â  this.addDataRow(siteRow);

Â  Â  Â  Â  Â  Â  const planoRow = ['', '', 'Plano Contratado:'];
Â  Â  Â  Â  Â  Â  chunk.forEach(company => {
Â  Â  Â  Â  Â  Â  Â  Â  planoRow.push(company.plano_contratado || '');
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  while (planoRow.length < 9) planoRow.push('');
Â  Â  Â  Â  Â  Â  this.addDataRow(planoRow);

Â  Â  Â  Â  Â  Â  const slaRow = ['', '', 'SLA Para Retorno:'];
Â  Â  Â  Â  Â  Â  chunk.forEach(company => {
Â  Â  Â  Â  Â  Â  Â  Â  slaRow.push(company.sla || '');
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  while (slaRow.length < 9) slaRow.push('');
Â  Â  Â  Â  Â  Â  this.addDataRow(slaRow);

Â  Â  Â  Â  Â  Â  this.addEmptyDataRow();
Â  Â  Â  Â  });
Â  Â  }

    addContractedServices(companies) {
        this.addDataRow(['', '', 'ServiÃ§os Contratados', '', '', '', '', '', '']);

        // Mapeamento de todos os serviÃ§os disponÃ­veis
        const servicosDisponiveis = [
            { campo: 'bpo_contabil', nome: 'BPO ContÃ¡bil' },
            { campo: 'bpo_fiscal', nome: 'BPO Fiscal' },
            { campo: 'bpo_folha', nome: 'BPO Folha' },
            { campo: 'bpo_financeiro', nome: 'BPO Financeiro' },
            { campo: 'bpo_rh', nome: 'BPO RH' },
            { campo: 'bpo_cnd', nome: 'CertidÃµes Negativas' }
        ];

        // Filtra apenas os serviÃ§os contratados (que tÃªm "Sim") e numera sequencialmente
        const servicosContratados = [];
        let numeroServico = 1;

        servicosDisponiveis.forEach(servico => {
            if (companies.some(c => c[servico.campo] === 'Sim')) {
                servicosContratados.push(['', '', `ServiÃ§o ${numeroServico}:`, servico.nome, '', '', '', '', '']);
                numeroServico++;
                logger.info(`ğŸ“‹ ServiÃ§o contratado: ${servico.nome}`);
            }
        });

        // Adiciona os serviÃ§os contratados Ã  planilha
        servicosContratados.forEach(servico => {
            this.addDataRow(servico);
        });

        // Se nenhum serviÃ§o foi contratado, adiciona uma linha indicando isso
        if (servicosContratados.length === 0) {
            this.addDataRow(['', '', 'Nenhum serviÃ§o contratado', '', '', '', '', '', '']);
        }

        this.addEmptyDataRow();
    }

    addMainContact(companies) {
        const firstCompany = companies[0];
        
        // Os dados jÃ¡ foram corrigidos na normalizaÃ§Ã£o - usar diretamente
        const nome = firstCompany.contato_principal_nome || '';
        const cargo = firstCompany.contato_principal_cargo || '';
        const email = firstCompany.contato_principal_email || '';
        const celular = firstCompany.contato_principal_celular || '';
        
        this.addDataRow(['', '', 'Contato Principal', '', '', '', '', '', '']);
        this.addDataRow(['', '', 'Nome:', nome, '', '', '', '', '']);
        this.addDataRow(['', '', 'Cargo:', cargo, '', '', '', '', '']);
        this.addDataRow(['', '', 'E-mail:', email, '', '', '', '', '']);
        this.addDataRow(['', '', 'Celular:', celular, '', '', '', '', '']);
        this.addEmptyDataRow();
    }

    // FunÃ§Ã£o para adicionar entendimento do negÃ³cio - VERSÃƒO CORRIGIDA
    addBusinessUnderstanding(companies) {
        const chunks = this.chunkArray(companies, 3);
        
        chunks.forEach(chunk => {
            const headerRow = ['', '', 'Entendimento do NegÃ³cio'];
            chunk.forEach(company => {
                headerRow.push(this.truncateCompanyName(company.nome_fantasia));
            });
            while (headerRow.length < 9) headerRow.push('');
            this.addDataRow(headerRow);

            // ================== LÃ“GICA DE FATURAMENTO CORRIGIDA ==================
            // Faturamento anual
            const faturamentoRow = ['', '', 'Faturamento anual:'];
            chunk.forEach(company => {
                const faturamentoString = company.faturamento_anual;
                
                if (typeof faturamentoString === 'string' && faturamentoString.trim() !== '') {
                    // Remove "R$" e espaÃ§os
                    let valor = faturamentoString.replace(/R\$|\s/g, '');
                    
                    // Detecta o formato da moeda
                    let valorNumerico;
                    
                    // Formato brasileiro: R$ 3.500.000,00 (ponto = milhares, vÃ­rgula = decimal)
                    if (valor.includes(',') && valor.lastIndexOf(',') > valor.lastIndexOf('.')) {
                        // Remove pontos (separadores de milhares) e substitui vÃ­rgula por ponto
                        valorNumerico = parseFloat(valor.replace(/\./g, '').replace(',', '.'));
                        logger.info(`ğŸ’° Formato brasileiro detectado: "${faturamentoString}" â†’ ${valorNumerico}`);
                    }
                    // Formato americano: R$ 3,500,000.00 (vÃ­rgula = milhares, ponto = decimal)
                    else if (valor.includes('.') && valor.lastIndexOf('.') > valor.lastIndexOf(',')) {
                        // Remove vÃ­rgulas (separadores de milhares), mantÃ©m o ponto decimal
                        valorNumerico = parseFloat(valor.replace(/,/g, ''));
                        logger.info(`ğŸ’° Formato americano detectado: "${faturamentoString}" â†’ ${valorNumerico}`);
                    }
                    // Apenas nÃºmeros com ponto (formato americano simples)
                    else if (valor.includes('.') && !valor.includes(',')) {
                        valorNumerico = parseFloat(valor);
                        logger.info(`ğŸ’° Formato americano simples: "${faturamentoString}" â†’ ${valorNumerico}`);
                    }
                    // Apenas nÃºmeros com vÃ­rgula (formato brasileiro simples)
                    else if (valor.includes(',') && !valor.includes('.')) {
                        valorNumerico = parseFloat(valor.replace(',', '.'));
                        logger.info(`ğŸ’° Formato brasileiro simples: "${faturamentoString}" â†’ ${valorNumerico}`);
                    }
                    // Apenas nÃºmeros inteiros
                    else {
                        valorNumerico = parseFloat(valor);
                        logger.info(`ğŸ’° Formato numÃ©rico puro: "${faturamentoString}" â†’ ${valorNumerico}`);
                    }

                    if (!isNaN(valorNumerico) && valorNumerico > 0) {
                        // Adiciona o NÃšMERO puro. A formataÃ§Ã£o serÃ¡ feita na escrita da planilha.
                        faturamentoRow.push(valorNumerico);
                    } else {
                        faturamentoRow.push('Sem Faturamento');
                        logger.info(`âŒ Erro no faturamento: "${faturamentoString}" â†’ NaN`);
                    }
                } else {
                    faturamentoRow.push('Sem Faturamento');
                }
            });
            while (faturamentoRow.length < 9) faturamentoRow.push('');
            this.addDataRow(faturamentoRow);
            // ======================================================================

            const fields = [
                { label: 'Regime TributÃ¡rio:', field: 'regime_tributario_atual', default: '' },
                { label: 'NF de Entrada:', field: 'nf_entradas', default: 0, isNumeric: true },
                { label: 'NF de SaÃ­da:', field: 'nf_saidas', default: 0, isNumeric: true },
                { label: 'CT-es de Entrada:', field: 'ctes_entrada', default: 0, isNumeric: true },
                { label: 'CT-es de SaÃ­da:', field: 'ctes_saida', default: 0, isNumeric: true },
                { label: 'NF de Prestados:', field: 'nf_servicos_prestados', default: 0, isNumeric: true },
                { label: 'NF de Tomados:', field: 'servicos_tomados', default: 0, isNumeric: true },
                { label: 'FuncionÃ¡rios PJ:', field: 'nf_pjs', default: 0, isNumeric: true },
                { label: 'Centros de Custo:', field: 'centro_custo_quantidade', default: 0, isNumeric: true }
            ];

            fields.forEach(({ label, field, default: defaultValue, isNumeric }) => {
                const row = ['', '', label];
                chunk.forEach(company => {
                    if (isNumeric) {
                        row.push(this.convertToNumber(company[field], defaultValue));
                    } else {
                        row.push(company[field] || defaultValue);
                    }
                });
                while (row.length < 9) row.push('');
                this.addDataRow(row);
            });

            this.addEmptyDataRow();
        });
    }

    addPayroll(companies) {
        const chunks = this.chunkArray(companies, 3);
        
        chunks.forEach(chunk => {
            const headerRow = ['', '', 'Folha de Pagamento'];
            chunk.forEach(company => {
                headerRow.push(this.truncateCompanyName(company.nome_fantasia));
            });
            while (headerRow.length < 9) headerRow.push('');
            this.addDataRow(headerRow);

            const fields = [
                { label: 'FuncionÃ¡rios CLT:', field: 'colab_clt', isNumeric: true },
                { label: 'PrÃ³-Labore:', field: 'pro_labore', isNumeric: true },
                { label: 'EstagiÃ¡rios:', field: 'estagiarios', isNumeric: true },
                { label: 'Aprendizes:', field: 'aprendizes', isNumeric: true },
                { label: 'AutÃ´nomos - RPA:', field: 'rpa', isNumeric: true },
                { label: 'DomÃ©sticas CLT:', field: 'domesticas_clt', isNumeric: true }
            ];

            fields.forEach(({ label, field, isNumeric }) => {
                const row = ['', '', label];
                chunk.forEach(company => {
                    if (isNumeric) {
                        row.push(this.convertToNumber(company[field], 0));
                    } else {
                        row.push(company[field] || 0);
                    }
                });
                while (row.length < 9) row.push('');
                this.addDataRow(row);
            });

            this.addEmptyDataRow();
        });
    }

    addSystemsInfo(companies) {
    // Passo 1: Coletar os valores de TODAS as empresas para os TRÃŠS campos.
    const contabeis = [...new Set(companies.map(c => c.sistema_contabil).filter(Boolean))];
    const folhas = [...new Set(companies.map(c => c.sistema_folha).filter(Boolean))];
    const fiscais = [...new Set(companies.map(c => c.sistema_fiscal).filter(Boolean))];
    const financeiros = [...new Set(companies.map(c => c.sistema_financeiro).filter(Boolean))];

    // Junta todos os sistemas encontrados em um Ãºnico array para anÃ¡lise.
    const todosOsSistemas = [...contabeis, ...folhas, ...fiscais, ...financeiros];

    // Passo 2: Descobrir quantos sistemas ÃšNICOS existem no total.
    const sistemasUnicosNoGeral = [...new Set(todosOsSistemas)];

    this.addEmptyDataRow();
    this.addDataRow(['', '', 'Sistemas', '', '', '', '', '', '']);

    // Passo 3: LÃ³gica de decisÃ£o
    // SE sÃ³ existe 1 sistema Ãºnico para todas as Ã¡reas (ContÃ¡bil, Folha, Fiscal)...
    if (sistemasUnicosNoGeral.length === 1) {
        // ...entÃ£o consolidamos a exibiÃ§Ã£o.
        const nomeDoSistema = sistemasUnicosNoGeral[0];
        const labels = [];

        if (contabeis.length > 0) labels.push('ContÃ¡bil');
        if (folhas.length > 0) labels.push('Folha');
        if (fiscais.length > 0) labels.push('Fiscal');
        if (financeiros.length > 0) labels.push('Financeiro');  
        
        // Formata o label de forma inteligente (ex: "ContÃ¡bil e Fiscal" ou "ContÃ¡bil, Folha e Fiscal")
        let finalLabel = '';
        if (labels.length > 1) {
            finalLabel = labels.slice(0, -1).join(', ') + ' e ' + labels.slice(-1);
        } else {
            finalLabel = labels.join('');
        }

        this.addDataRow(['', '', `${finalLabel}:`, nomeDoSistema, '', '', '', '', '']);

    } else {
        // SE os sistemas sÃ£o diferentes (ou nÃ£o hÃ¡ nenhum), mostramos em linhas separadas.
        const textoContabil = contabeis.join(', ');
        const textoFolha = folhas.join(', ');
        const textoFiscal = fiscais.join(', ');
        const textoFinanceiro = financeiros.join(', ');

        if (textoFinanceiro) {
            this.addDataRow(['', '', 'Financeiro:', textoFinanceiro, '', '', '', '', '']);
        }

        if (textoContabil) {
            this.addDataRow(['', '', 'ContÃ¡bil:', textoContabil, '', '', '', '', '']);
        }
        if (textoFolha) {
            this.addDataRow(['', '', 'Folha de Pagamento:', textoFolha, '', '', '', '', '']);
        }
        if (textoFiscal) {
            this.addDataRow(['', '', 'Fiscal:', textoFiscal, '', '', '', '', '']);
        }
    }

    this.addEmptyDataRow();
}

    addAccountingInfo(companies) {
        const chunks = this.chunkArray(companies, 3);
        
        chunks.forEach(chunk => {
            const headerRow = ['', '', 'Contabilidade e Fiscal'];
            chunk.forEach(company => {
                headerRow.push(this.truncateCompanyName(company.nome_fantasia));
            });
            while (headerRow.length < 9) headerRow.push('');
            this.addDataRow(headerRow);

            const deadlineRow = ['', '', 'Deadline:'];
            chunk.forEach(company => {
                // Monta deadline dinÃ¢mico baseado nos campos da API
                // Monta deadline dinÃ¢mico baseado nos campos da API
                const deadlineParts = [];

                if (company.deadline_util_corrente) {
                    deadlineParts.push(company.deadline_util_corrente);
                }
                if (company.deadline_periodicidade) {
                    deadlineParts.push(company.deadline_periodicidade);
                }
                if (company.deadline_dia) {
                    deadlineParts.push(`Dia ${company.deadline_dia}`);
                }

                // Junta as partes que existem com ", "
                const deadline = deadlineParts.join(', '); 
                deadlineRow.push(deadline);
            });
            while (deadlineRow.length < 9) deadlineRow.push('');
            this.addDataRow(deadlineRow);

            const cnaeRow = ['', '', 'CNAE:'];
            chunk.forEach(company => {
                cnaeRow.push(company.atividade_especialidade || '');
            });
            while (cnaeRow.length < 9) cnaeRow.push('');
            this.addDataRow(cnaeRow);

            this.addEmptyDataRow();
        });
    }

    addCommercialInfo(companies) {
    const firstCompany = companies[0];
    
    // Empresas abertas pela Go Further - agora vem da API
    this.addDataRow(['', '', 'Empresas abertas pela Go Further?', '', firstCompany.empresa_aberta_go || '', '', '', '', '']);
    this.addEmptyDataRow();
    
    // CobranÃ§a de ImplantaÃ§Ã£o - agora vem da API
    this.addDataRow(['', '', 'HaverÃ¡ CobranÃ§a de ImplantaÃ§Ã£o:', '', firstCompany.implantacao || '', '', '', '', '']);
    this.addDataRow(['', '', 'Vencimento:', '', firstCompany.vencimento_implantacao || '', '', '', '', '']);
    this.addEmptyDataRow();
    
    this.addDataRow(['', '', 'Faturar por:', '', '', '', '', '', '']);
    
    // Mapeamento completo de todos os 6 serviÃ§os BPO
    const servicosFaturamento = [
        { 
            campo: 'bpo_contabil', 
            nome: 'ContÃ¡bil', 
            faturadoPor: 'bpo_contabil_faturado',
            default: ''
        },
        { 
            campo: 'bpo_fiscal', 
            nome: 'Fiscal', 
            faturadoPor: 'bpo_fiscal_faturado',
            default: ''
        },
        { 
            campo: 'bpo_folha', 
            nome: 'Folha', 
            faturadoPor: 'bpo_folha_faturado',
            default: ''
        },
        { 
            campo: 'bpo_financeiro', 
            nome: 'Financeiro', 
            faturadoPor: 'bpo_financeiro_faturado',
            default: ''
        },
        { 
            campo: 'bpo_rh', 
            nome: 'RH', 
            faturadoPor: 'bpo_rh_faturado',
            default: ''
        },
        { 
            campo: 'bpo_cnd', 
            nome: 'BPO Legal', 
            faturadoPor: 'bpo_legal_faturado', // Mapeia bpo_cnd para bpo_legal_faturado
            default: ''
        }
    ];

    // Processa cada serviÃ§o se estiver contratado
    servicosFaturamento.forEach(servico => {
        // Verifica se alguma empresa tem o serviÃ§o contratado
        if (companies.some(c => c[servico.campo] === 'Sim')) {
            // Pega o valor do campo faturado da API ou usa o default
            let faturadoPor = firstCompany[servico.faturadoPor];
            
            // Se o campo estiver vazio ou for null/undefined, usa o default (agora vazio)
            if (!faturadoPor || faturadoPor.trim() === '') {
                faturadoPor = servico.default;
                logger.info(`âš ï¸  Campo ${servico.faturadoPor} vazio, usando default: vazio`);
            } else {
                logger.info(`âœ… Campo ${servico.faturadoPor} da API: ${faturadoPor}`);
            }
            
            this.addDataRow(['', '', servico.nome, '', faturadoPor, '', '', '', '']);
            logger.info(`ğŸ“‹ ${servico.nome} faturado por: ${faturadoPor}`);
        }
    });
    
    this.addEmptyDataRow();
    
    this.addDataRow(['', '', 'Comercial', '', '', '', '', '', '']);
    this.addDataRow(['', '', 'Closer:', firstCompany.closer || '', '', '', '', '', '']);
    this.addDataRow(['', '', 'Prospector:', firstCompany.prospector || '', '', '', '', '', '']);
    
    if (firstCompany.observacao_closer) {
        this.addDataRow(['', '', 'Obs Closer:', firstCompany.observacao_closer, '', '', '', '', '']);
    }
    
    if (firstCompany.observacoes_cadastro) {
        this.addDataRow(['', '', 'Obs:', firstCompany.observacoes_cadastro, '', '', '', '', '']);
    }
}

    // Nova seÃ§Ã£o: HonorÃ¡rios e CobranÃ§a
    addHonorarios(companies) {
        const chunks = this.chunkArray(companies, 3);
        
        chunks.forEach(chunk => {
            const headerRow = ['', '', 'HonorÃ¡rios e CobranÃ§a'];
            chunk.forEach(company => {
                headerRow.push(this.truncateCompanyName(company.nome_fantasia));
            });
            while (headerRow.length < 9) headerRow.push('');
            this.addDataRow(headerRow);

            // Mapeamento de serviÃ§os com valores
            const servicosHonorarios = [
                { campo: 'bpo_contabil', nome: 'BPO ContÃ¡bil', valorCampo: 'vl_bpo_contabil' },
                { campo: 'bpo_fiscal', nome: 'BPO Fiscal', valorCampo: 'vl_bpo_fiscal' },
                { campo: 'bpo_folha', nome: 'BPO Folha', valorCampo: 'vl_bpo_folha' },
                { campo: 'bpo_financeiro', nome: 'BPO Financeiro', valorCampo: 'vl_bpo_financeiro' },
                { campo: 'bpo_rh', nome: 'BPO RH', valorCampo: 'vl_bpo_rh' },
                { campo: 'bpo_cnd', nome: 'BPO Legal', valorCampo: 'vl_bpo_legal' }
            ];

            servicosHonorarios.forEach(servico => {
                // Verificar se alguma empresa do chunk tem o serviÃ§o contratado
                const temServicoContratado = chunk.some(c => c[servico.campo] === 'Sim');
                
                if (temServicoContratado) {
                    const servicoRow = ['', '', servico.nome + ':'];
                    chunk.forEach(company => {
                        if (company[servico.campo] === 'Sim') {
                            const valor = CurrencyUtils.processForSpreadsheet(company[servico.valorCampo]);
                            servicoRow.push(valor);
                        } else {
                            servicoRow.push('R$ 0,00');
                        }
                    });
                    while (servicoRow.length < 9) servicoRow.push('');
                    this.addDataRow(servicoRow);
                }
            });

            // Total mensal
            const totalRow = ['', '', 'Total Mensal:'];
            chunk.forEach(company => {
                const total = CurrencyUtils.processForSpreadsheet(company.honorario_mensal_total);
                totalRow.push(total);
            });
            while (totalRow.length < 9) totalRow.push('');
            this.addDataRow(totalRow);

            this.addEmptyDataRow();
        });
    }

    async generateForGroup(groupName, companiesData = null) {
        try {
            logger.info(`Buscando dados para o grupo: ${groupName}`);
            
            // Se os dados das empresas foram fornecidos, usa eles; senÃ£o busca da API
            let companies;
            if (companiesData && Array.isArray(companiesData) && companiesData.length > 0) {
                companies = companiesData.map(c => this.normalizeCompany(c));
                logger.info(`Usando dados fornecidos: ${companies.length} empresas (normalizadas)`);
            } else {
                const rawCompanies = await this.fetchGroupData(groupName);
                companies = Array.isArray(rawCompanies) ? rawCompanies.map(c => this.normalizeCompany(c)) : [];
                logger.info(`Dados buscados da API: ${companies ? companies.length : 0} empresas (normalizadas)`);
            }
            
            if (!companies || companies.length === 0) {
                throw new Error('Nenhuma empresa encontrada para o grupo especificado');
            }

            logger.info(`Encontradas ${companies.length} empresas. Gerando planilha...`);

            // Reset das variÃ¡veis para nova geraÃ§Ã£o
            this.workbook = new ExcelJS.Workbook();
            this.worksheet = null;
            this.currentRow = 1;
            this.dataRows = [];

            this.companyNames = companies.map(company => this.truncateCompanyName(company.nome_fantasia)).filter(name => name.trim() !== '');
            logger.info(`ğŸ“‹ Nomes de empresas identificados: ${this.companyNames.length} (mÃ¡x. ${this.maxCompanyNameLength} chars)`);

            logger.info('ğŸ“Š Coletando todos os dados...');
            this.addGroupHeader(groupName);
            this.addCompanyBasicInfo(companies);
            this.addContractedServices(companies);
            this.addMainContact(companies);
            this.addBusinessUnderstanding(companies);
            this.addPayroll(companies);
            this.addSystemsInfo(companies);
            this.addAccountingInfo(companies);
            this.addCommercialInfo(companies);

            const fixedWidths = this.getFixedColumnWidths();

            this.worksheet = this.workbook.addWorksheet('Board');
            this.setupColumns(fixedWidths);

            this.writeDataToWorksheet();

            // Adiciona a imagem na linha 3
            await this.addImageToWorksheet();

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const fileName = `${groupName.replace(/\s+/g, '_')}_Ficha_Entrada_${timestamp}.xlsx`;
            const filePath = path.join(this.outputDir, fileName);
            
            logger.info('ğŸ’¾ Salvando arquivo...');
            
            // Configurar options para garantir UTF-8
            await this.workbook.xlsx.writeFile(filePath);

            logger.info('âœ… Planilha gerada com sucesso!');
            logger.info(`ğŸ“ Arquivo: ${fileName}`);
            logger.info(`ğŸ“ˆ Total de empresas: ${companies.length}`);
            logger.info(`ğŸ“„ Total de linhas: ${this.currentRow}`);

            return {
                success: true,
                fileName: fileName,
                filePath: filePath,
                stats: {
                    companies: companies.length,
                    rows: this.currentRow
                }
            };

        } catch (error) {
            logger.error('Erro ao gerar planilha:', error.message);
            throw error;
        }
    }

    // Novo mÃ©todo para gerar planilhas por tipo
    async generateSpreadsheetByType(groupName, companiesData, tipo = 'entrada') {
        try {
            logger.info(`Gerando planilha tipo "${tipo}" para o grupo: ${groupName}`);
            
            let companies;
            if (companiesData && Array.isArray(companiesData) && companiesData.length > 0) {
                companies = companiesData.map(c => this.normalizeCompany(c));
                logger.info(`Usando dados fornecidos: ${companies.length} empresas (normalizadas)`);
            } else {
                const rawCompanies = await this.fetchGroupData(groupName);
                companies = Array.isArray(rawCompanies) ? rawCompanies.map(c => this.normalizeCompany(c)) : [];
                logger.info(`Dados buscados da API: ${companies ? companies.length : 0} empresas (normalizadas)`);
            }
            
            if (!companies || companies.length === 0) {
                throw new Error('Nenhuma empresa encontrada para o grupo especificado');
            }

            // Reset das variÃ¡veis para nova geraÃ§Ã£o
            this.workbook = new ExcelJS.Workbook();
            this.worksheet = null;
            this.currentRow = 1;
            this.dataRows = [];

            this.companyNames = companies.map(company => this.truncateCompanyName(company.nome_fantasia)).filter(name => name.trim() !== '');
            logger.info(`ğŸ“‹ Nomes de empresas identificados: ${this.companyNames.length} (mÃ¡x. ${this.maxCompanyNameLength} chars)`);

            logger.info(`ğŸ“Š Coletando dados para planilha tipo: ${tipo}`);
            
            if (tipo === 'entrada') {
                // Planilha de entrada (original)
                this.addGroupHeader(groupName);
                this.addCompanyBasicInfo(companies);
                this.addContractedServices(companies);
                this.addMainContact(companies);
                this.addBusinessUnderstanding(companies);
                this.addPayroll(companies);
                this.addSystemsInfo(companies);
                this.addAccountingInfo(companies);
                this.addCommercialInfo(companies);
            } else if (tipo === 'cobranca') {
                // Planilha de honorÃ¡rios e cobranÃ§a
                this.addGroupHeader(groupName);
                this.addCompanyBasicInfo(companies);
                this.addContractedServices(companies);
                this.addMainContact(companies);
                this.addBusinessUnderstanding(companies);
                this.addPayroll(companies);
                this.addSystemsInfo(companies);
                this.addAccountingInfo(companies);
                this.addHonorarios(companies); // Nova seÃ§Ã£o
                this.addCommercialInfo(companies);
            }

            const fixedWidths = this.getFixedColumnWidths();

            this.worksheet = this.workbook.addWorksheet('Board');
            this.setupColumns(fixedWidths);

            this.writeDataToWorksheet();

            // Adiciona a imagem na linha 3
            await this.addImageToWorksheet();

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const tipoSuffix = tipo === 'entrada' ? 'Entrada' : 'Cobranca';
            const fileName = `${groupName.replace(/\s+/g, '_')}_Ficha_${tipoSuffix}_${timestamp}.xlsx`;
            const filePath = path.join(this.outputDir, fileName);
            
            logger.info('ğŸ’¾ Salvando arquivo...');
            
            // Configurar options para garantir UTF-8
            await this.workbook.xlsx.writeFile(filePath);

            logger.info(`âœ… Planilha tipo "${tipo}" gerada com sucesso!`);
            logger.info(`ğŸ“ Arquivo: ${fileName}`);
            logger.info(`ğŸ“ˆ Total de empresas: ${companies.length}`);
            logger.info(`ğŸ“„ Total de linhas: ${this.currentRow}`);

            return {
                success: true,
                fileName: fileName,
                filePath: filePath,
                tipo: tipo,
                stats: {
                    companies: companies.length,
                    rows: this.currentRow
                }
            };

        } catch (error) {
            logger.error(`Erro ao gerar planilha tipo "${tipo}":`, error.message);
            throw error;
        }
    }

    // MÃ©todo para manter compatibilidade com controller existente
    async generateXlsx(groupName, companies, tipoRelatorio = 'entrada', userId = null) {
        try {
            if (!groupName) {
                throw new Error('Nome do grupo Ã© obrigatÃ³rio');
            }

            return await this.generateForGroup(groupName, companies);
        } catch (error) {
            logger.error('Erro no generateXlsx:', error);
            throw error;
        }
    }

    async downloadFile(fileName) {
        const filePath = path.join(this.outputDir, fileName);
        
        if (!fs.existsSync(filePath)) {
            throw new Error('Arquivo nÃ£o encontrado');
        }

        return {
            filePath: filePath,
            fileName: fileName,
            mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        };
    }

    listAvailableFiles() {
        try {
            if (!fs.existsSync(this.outputDir)) {
                return [];
            }

            const files = fs.readdirSync(this.outputDir)
                .filter(file => file.endsWith('.xlsx'))
                .map(file => {
                    const filePath = path.join(this.outputDir, file);
                    const stats = fs.statSync(filePath);
                    
                    return {
                        fileName: file,
                        downloadUrl: `/api/xlsx-generator/download/${file}`,
                        tamanho: stats.size,
                        criadoEm: stats.birthtime,
                        modificadoEm: stats.mtime
                    };
                })
                .sort((a, b) => new Date(b.criadoEm) - new Date(a.criadoEm));

            return files;
        } catch (error) {
            logger.error('Erro ao listar arquivos:', error);
            return [];
        }
    }

    // MÃ©todo para verificar se um arquivo existe
    fileExists(fileName) {
        try {
            const filePath = path.join(this.outputDir, fileName);
            return fs.existsSync(filePath);
        } catch (error) {
            logger.error('Erro ao verificar existÃªncia do arquivo:', error);
            return false;
        }
    }

    // MÃ©todo para obter o caminho completo de um arquivo
    getFilePath(fileName) {
        return path.join(this.outputDir, fileName);
    }

    // MÃ©todo para limpeza de arquivos antigos
    cleanupOldFiles(maxAgeInDays = 7) {
        try {
            if (!fs.existsSync(this.outputDir)) {
                logger.info('DiretÃ³rio de arquivos nÃ£o existe, nada para limpar');
                return { deleted: 0, total: 0 };
            }

            const files = fs.readdirSync(this.outputDir).filter(file => file.endsWith('.xlsx'));
            const now = Date.now();
            const maxAge = maxAgeInDays * 24 * 60 * 60 * 1000; // dias em millisegundos
            let deletedCount = 0;

            for (const file of files) {
                const filePath = path.join(this.outputDir, file);
                const stats = fs.statSync(filePath);
                
                if (now - stats.mtime.getTime() > maxAge) {
                    fs.unlinkSync(filePath);
                    deletedCount++;
                    logger.info(`Arquivo antigo removido: ${file}`);
                }
            }

            logger.info(`Limpeza concluÃ­da: ${deletedCount}/${files.length} arquivos removidos`);
            return { deleted: deletedCount, total: files.length };

        } catch (error) {
            logger.error('Erro na limpeza de arquivos:', error);
            return { deleted: 0, total: 0, error: error.message };
        }
    }

    // MÃ©todo para gerar dados da tabela em formato JSON para visualizaÃ§Ã£o
    async generateTableData(groupName, companies) {
        try {
            if (!companies || companies.length === 0) {
                throw new Error('Nenhuma empresa encontrada para gerar dados da tabela');
            }

            // Estrutura de dados similar Ã  planilha
            const tableData = {
                header: {
                    title: `Ficha de Entrada - ${groupName}`,
                    empresas: companies.length,
                    geradoEm: new Date().toLocaleString('pt-BR')
                },
                companies: companies.map(company => ({
                    id: company.id || '',
                    nome_fantasia: company.nome_fantasia || '',
                    razao_social: company.razao_social || '',
                    cnpj: company.cnpj || '',
                    endereco: company.endereco || '',
                    telefone: company.telefone || '',
                    email: company.email || '',
                    responsavel: company.responsavel || '',
                    observacoes: company.observacoes || '',
                    grupo: company.grupo || groupName,
                    ativo: company.ativo || true
                })),
                summary: {
                    totalEmpresas: companies.length,
                    empresasAtivas: companies.filter(c => c.ativo !== false).length,
                    grupos: [...new Set(companies.map(c => c.grupo || groupName))]
                }
            };

            return tableData;

        } catch (error) {
            logger.error('Erro ao gerar dados da tabela:', error);
            throw error;
        }
    }
}

module.exports = new XlsxGeneratorService();
