const ExcelJS = require('exceljs');
const fs = require('fs');
const path = require('path');
const logger = require('../utils/logger');
const axios = require('axios');

class XlsxGeneratorService {
    constructor() {
        this.outputDir = path.join(__dirname, '../storage/generated-reports');
        this.ensureOutputDir();
        
        this.workbook = new ExcelJS.Workbook();
        this.worksheet = null;
        this.currentRow = 1;
        this.dataRows = []; // Array para armazenar todas as linhas antes da escrita
        
        this.boldLabels = [
            'Apelido:', 'C√≥digo no sistema Dom√≠nio:', 'Raz√£o Social:', 'CNPJ:', 
            'Vig√™ncia Inicial:', 'Site:', 'Plano Contratado:', 'SLA Para Retorno:',
            'Servi√ßos Contratados', 'Servi√ßo 1:', 'Servi√ßo 2:', 'Servi√ßo 3:', 'Servi√ßo 4:', 'Servi√ßo 5:', 'Servi√ßo 6:',
            'Contato Principal', 'Nome:', 'Cargo:', 'E-mail:', 'Celular:',
            'Entendimento do Neg√≥cio', 'Faturamento anual:', 'Regime Tribut√°rio:',
            'NF de Entrada:', 'NF de Sa√≠da:', 'CT-es de Entrada:', 'CT-es de Sa√≠da:',
            'NF de Prestados:', 'NF de Tomados:', 'Funcion√°rios PJ:', 'Centros de Custo:',
            'Folha de Pagamento', 'Funcion√°rios CLT:', 'Pr√≥-Labore:', 'Estagi√°rios:',
            'Aprendizes:', 'Aut√¥nomos - RPA:', 'Dom√©sticas CLT:', 'Sistemas',
            'Cont√°bil e Fiscal:', 'Contabilidade e Fiscal', 'Deadline:', 'CNAE:',
            'Comercial', 'Closer:', 'Prospector:', 'Obs:'
        ];

        // Definir estilos
        this.styles = {
            default: {
                font: { name: 'Calibri', size: 11 },
                alignment: { vertical: 'top', horizontal: 'left' }
            },
            bold: {
                font: { name: 'Calibri', size: 11, bold: true },
                alignment: { vertical: 'top', horizontal: 'left' }
            },
            sectionHeader: {
                font: { name: 'Calibri', size: 12, bold: true },
                alignment: { vertical: 'top', horizontal: 'left' },
                fill: { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFADDBDC' } }
            },
            mainHeader: {
                font: { name: 'Calibri', size: 25, bold: true, color: { argb: 'FF000000' } },
                alignment: { vertical: 'middle', horizontal: 'left' }
            },
            companyName: {
                font: { name: 'Calibri', size: 11, bold: true },
                alignment: { vertical: 'top', horizontal: 'left' }
            }
        };

        // Lista de nomes de empresas para aplicar negrito
        this.companyNames = [];
        
        // Configura√ß√£o de truncamento
        this.maxCompanyNameLength = 52;
    }

    ensureOutputDir() {
        if (!fs.existsSync(this.outputDir)) {
            fs.mkdirSync(this.outputDir, { recursive: true });
            logger.info('üìÅ Diret√≥rio de relat√≥rios criado', { path: this.outputDir });
        }
    }

    // Fun√ß√£o para converter valores para n√∫meros nativos (evita "n√∫mero armazenado como texto")
    convertToNumber(value, defaultValue = 0) {
        if (value === null || value === undefined || value === '') {
            return defaultValue;
        }
        
        // Se j√° √© um n√∫mero, retorna como est√°
        if (typeof value === 'number') {
            return value;
        }
        
        // Se √© string, tenta converter para n√∫mero
        if (typeof value === 'string') {
            const trimmed = value.trim();
            
            // Se string vazia ap√≥s trim, retorna default
            if (trimmed === '') {
                return defaultValue;
            }
            
            // Tenta converter para n√∫mero
            const parsed = parseFloat(trimmed);
            
            // Se convers√£o foi bem sucedida e √© um n√∫mero v√°lido
            if (!isNaN(parsed) && isFinite(parsed)) {
                return parsed;
            }
        }
        
        // Se n√£o conseguiu converter, retorna o valor original
        return value;
    }

    truncateCompanyName(name) {
        if (!name) return '';
        const nameStr = String(name).trim();
        if (nameStr.length <= this.maxCompanyNameLength) {
            return nameStr;
        }
        const truncated = nameStr.substring(0, this.maxCompanyNameLength - 3) + '...';
        logger.info(`‚úÇÔ∏è Nome truncado: "${nameStr}" ‚Üí "${truncated}" (${nameStr.length} ‚Üí ${truncated.length} chars)`);
        return truncated;
    }

    // Fun√ß√£o para buscar dados da API
    async fetchGroupData(groupName) {
        try {
            const API_BASE_URL = 'http://localhost:3001/api/group-search';
            const encodedGroupName = encodeURIComponent(groupName);
            const response = await axios.get(`${API_BASE_URL}/${encodedGroupName}`, {
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            if (response.data && response.data.success && response.data.empresas) {
                return response.data.empresas;
            } else {
                throw new Error('Formato de resposta inv√°lido da API');
            }
        } catch (error) {
            logger.error('Erro ao buscar dados da API:', error.message);
            throw error;
        }
    }

    // Fun√ß√£o para definir larguras fixas das colunas
    getFixedColumnWidths() {
        logger.info('üìê Aplicando larguras fixas das colunas...');
        
        const fixedWidths = [
            1.22,  // Coluna A (vazia)
            1.89,  // Coluna B (vazia)
            30,    // Coluna C (labels)
            50.11, // Coluna D
            54.78, // Coluna E  
            35,    // Coluna F
            14.89, // Coluna G
            1.22,  // Coluna H (vazia, mesmo tamanho da A)
            1.89   // Coluna I (vazia, mesmo tamanho da B)
        ];
        
        logger.info('üìä Larguras fixas:', fixedWidths.map((w, i) => `${String.fromCharCode(65 + i)}:${w}`).join(', '));
        logger.info('üôà Colunas J+ ser√£o ocultadas');
        
        return fixedWidths;
    }

    // Fun√ß√£o para configurar larguras das colunas fixas e ocultar colunas desnecess√°rias
    setupColumns(fixedWidths) {
        // Aplica larguras fixas at√© a coluna I
        const columns = fixedWidths.map(width => ({ width }));
        this.worksheet.columns = columns;
        
        // Oculta todas as colunas ap√≥s I (coluna 9, √≠ndice 8)
        for (let colIndex = 9; colIndex <= 50; colIndex++) { // Oculta J, K, L... at√© uma coluna alta
            const column = this.worksheet.getColumn(colIndex + 1);
            column.hidden = true;
        }
        
        this.worksheet.views = [
            { showGridLines: false }
        ];
        
        logger.info('‚úÖ Larguras fixas das colunas configuradas (A-I)');
        logger.info('üôà Colunas J+ ocultadas');
        logger.info('üî≤ Linhas de grade desativadas');
    }

    // Fun√ß√£o para adicionar dados √† estrutura interna (n√£o escreve na planilha ainda)
    addDataRow(data, styleType = 'default') {
        const paddedData = [...data];
        while (paddedData.length < 9) paddedData.push(''); // Apenas at√© coluna I (9 colunas)
        
        this.dataRows.push({
            data: paddedData,
            styleType: styleType,
            rowNumber: this.currentRow
        });
        
        this.currentRow++;
        return this.dataRows.length - 1;
    }

    // Fun√ß√£o para adicionar linha vazia √† estrutura interna
    addEmptyDataRow() {
        return this.addDataRow(['', '', '', '', '', '', '', '', '']); // A at√© I (9 colunas)
    }

    // Fun√ß√£o para escrever todos os dados na planilha com formata√ß√£o
    writeDataToWorksheet() {
        logger.info('üìù Escrevendo dados na planilha com formata√ß√£o...');
        
        this.dataRows.forEach((rowData, index) => {
            const row = this.worksheet.addRow(rowData.data);
            
            row.eachCell((cell, colNumber) => {
                cell.font = this.styles[rowData.styleType].font;
                cell.alignment = this.styles[rowData.styleType].alignment;
                if (this.styles[rowData.styleType].fill) {
                    cell.fill = this.styles[rowData.styleType].fill;
                }
            });

            let isSectionHeader = false;
            if (rowData.data[2]) {
                const cellValue = String(rowData.data[2]).trim();
                isSectionHeader = ['Servi√ßos Contratados', 'Contato Principal', 'Entendimento do Neg√≥cio', 
                                 'Folha de Pagamento', 'Sistemas', 'Contabilidade e Fiscal', 'Comercial'].includes(cellValue);
            }

            if (rowData.data[2]) {
                const cellValue = String(rowData.data[2]).trim();
                const isLabel = this.boldLabels.includes(cellValue) ||
                               cellValue.startsWith('Novo cliente -') ||
                               cellValue.startsWith('Empresas abertas') ||
                               cellValue.startsWith('Haver√° Cobran√ßa') ||
                               cellValue.startsWith('Vencimento:') ||
                               cellValue.startsWith('Faturar por:');
                
                if (isLabel) {
                    const cellC = row.getCell(3);
                    
                    if (isSectionHeader) {
                        for (let colNum = 3; colNum <= 9; colNum++) { // Apenas at√© coluna I
                            const cell = row.getCell(colNum);
                            cell.font = this.styles.sectionHeader.font;
                            cell.fill = this.styles.sectionHeader.fill;
                        }
                    } else if (cellValue.startsWith('Novo cliente -')) {
                        cellC.font = this.styles.mainHeader.font;
                        cellC.alignment = this.styles.mainHeader.alignment;
                    } else {
                        cellC.font = this.styles.bold.font;
                    }
                }
            }
            
            // ================== FORMATA√á√ÉO DE MOEDA ==================
            // Verifica se √© a linha de "Faturamento anual:" para aplicar o formato de moeda
            if (rowData.data[2] && String(rowData.data[2]).trim() === 'Faturamento anual:') {
                // Itera sobre as colunas D, E, F (√≠ndices 3, 4, 5)
                for (let colIndex = 3; colIndex <= 5; colIndex++) {
                    const cell = row.getCell(colIndex + 1);
                    // Aplica o formato apenas se o valor for um n√∫mero
                    if (typeof cell.value === 'number') {
                        cell.numFmt = '"R$" #,##0.00';
                    }
                }
            }
            // ==========================================================

            for (let colIndex = 3; colIndex <= 5; colIndex++) {
                if (rowData.data[colIndex]) {
                    const cellValue = String(rowData.data[colIndex]).trim();
                    const isCompanyName = this.companyNames.includes(cellValue);
                    
                    if (isCompanyName && !isSectionHeader) {
                        const cell = row.getCell(colIndex + 1);
                        cell.font = this.styles.companyName.font;
                    }
                }
            }

            if (rowData.data[2] && String(rowData.data[2]).trim() === 'Site:') {
                for (let colIndex = 3; colIndex <= 5; colIndex++) {
                    if (rowData.data[colIndex] && String(rowData.data[colIndex]).trim().startsWith('http')) {
                        const cell = row.getCell(colIndex + 1);
                        const url = String(rowData.data[colIndex]).trim();
                        cell.value = {
                            text: url,
                            hyperlink: url
                        };
                        cell.font = {
                            ...this.styles.default.font,
                            color: { argb: 'FF000000' },
                            underline: true
                        };
                    }
                }
            }
        });

        this.applyMergedCells();
    }

    // Fun√ß√£o para adicionar imagem na linha 3
    async addImageToWorksheet() {
        try {
            // Verifica se o arquivo image.png existe no diret√≥rio
            const imagePath = path.join(__dirname, '../image.png');
            if (!fs.existsSync(imagePath)) {
                logger.info('‚ö†Ô∏è  Arquivo image.png n√£o encontrado. Pulando inser√ß√£o da imagem.');
                return;
            }

            logger.info('üìÅ Arquivo image.png encontrado, processando...');

            // L√™ o arquivo de imagem
            const imageBuffer = fs.readFileSync(imagePath);
            logger.info(`üìä Tamanho da imagem: ${imageBuffer.length} bytes`);
            
            // Adiciona a imagem ao workbook
            const imageId = this.workbook.addImage({
                buffer: imageBuffer,
                extension: 'png',
            });

            logger.info(`üÜî ID da imagem no workbook: ${imageId}`);

            // Ajusta a altura da linha 3 - menor altura vertical
            const row3 = this.worksheet.getRow(3);
            row3.height = 60; // Altura menor para n√£o ocupar muito espa√ßo vertical

            // Insere a imagem na linha 3 - come√ßando na coluna C
            this.worksheet.addImage(imageId, {
                tl: { col: 2, row: 2 }, // Top-left: coluna C (2), linha 3 (√≠ndice 2) 
                ext: { width: 1500, height: 55 }, // Dimens√µes perfeitas para logo largo
                editAs: 'oneCell'
            });

            logger.info('üñºÔ∏è  Imagem inserida na linha 3 (C3)');
        } catch (error) {
            logger.info('‚ö†Ô∏è  Erro ao inserir imagem:', error.message);
            logger.info('Continuando sem a imagem...');
        }
    }

    applyMergedCells() {
        this.dataRows.forEach((rowData, index) => {
            if (rowData.data[2] && String(rowData.data[2]).startsWith('Novo cliente -')) {
                const excelRowNumber = index + 1;
                this.worksheet.mergeCells(`C${excelRowNumber}:I${excelRowNumber}`); // Mescla apenas at√© I
                
                const mergedCell = this.worksheet.getCell(`C${excelRowNumber}`);
                mergedCell.font = this.styles.mainHeader.font;
                mergedCell.alignment = this.styles.mainHeader.alignment;
            }
        });
    }

    addGroupHeader(groupName) {
        // Linha 1: Vazia (espa√ßamento)
        this.addEmptyDataRow();
        
        // Linha 2: Vazia (espa√ßamento) 
        this.addEmptyDataRow();
        
        // Linha 3: Ser√° reservada para a imagem (linha vazia aqui, imagem ser√° adicionada depois)
        this.addEmptyDataRow();
        
        // Linha 4: Novo cliente - agora come√ßando na coluna C
        this.addDataRow(['', '', `Novo cliente - ${groupName}`, '', '', '', '', '', '']);
        this.addEmptyDataRow();
    }

    chunkArray(array, size) {
        const chunks = [];
        for (let i = 0; i < array.length; i += size) {
            chunks.push(array.slice(i, i + size));
        }
        return chunks;
    }

    addCompanyBasicInfo(companies) {
        const chunks = this.chunkArray(companies, 3);
        
        chunks.forEach(chunk => {
            const apelidoRow = ['', '', 'Apelido:'];
            chunk.forEach(company => {
                apelidoRow.push(this.truncateCompanyName(company.nome_fantasia));
            });
            while (apelidoRow.length < 9) apelidoRow.push('');
            this.addDataRow(apelidoRow);

            const codigoRow = ['', '', 'C√≥digo no sistema Dom√≠nio:'];
            chunk.forEach(company => {
                codigoRow.push(this.convertToNumber(company.codigo, ''));
            });
            while (codigoRow.length < 9) codigoRow.push('');
            this.addDataRow(codigoRow);

            const razaoRow = ['', '', 'Raz√£o Social:'];
            chunk.forEach(company => {
                razaoRow.push(company.razao_social || '');
            });
            while (razaoRow.length < 9) razaoRow.push('');
            this.addDataRow(razaoRow);

            const cnpjRow = ['', '', 'CNPJ:'];
            chunk.forEach(company => {
                cnpjRow.push(company.cnpj || '');
            });
            while (cnpjRow.length < 9) cnpjRow.push('');
            this.addDataRow(cnpjRow);

            const vigenciaRow = ['', '', 'Vig√™ncia Inicial:'];
            chunk.forEach(company => {
                const dataInicio = company.inicio_contrato ? new Date(company.inicio_contrato) : new Date();
                const mes = String(dataInicio.getMonth() + 1).padStart(2, '0');
                const ano = dataInicio.getFullYear();
                vigenciaRow.push(`${mes}/${ano}`);
            });
            while (vigenciaRow.length < 9) vigenciaRow.push('');
            this.addDataRow(vigenciaRow);

            const siteRow = ['', '', 'Site:'];
            chunk.forEach(company => {
                siteRow.push('https://teklamatik.com.br/');
            });
            while (siteRow.length < 9) siteRow.push('');
            this.addDataRow(siteRow);

            const planoRow = ['', '', 'Plano Contratado:'];
            chunk.forEach(company => {
                planoRow.push(company.plano_contratado || 'Advanced');
            });
            while (planoRow.length < 9) planoRow.push('');
            this.addDataRow(planoRow);

            const slaRow = ['', '', 'SLA Para Retorno:'];
            chunk.forEach(company => {
                slaRow.push(company.sla || '48 horas √∫teis');
            });
            while (slaRow.length < 9) slaRow.push('');
            this.addDataRow(slaRow);

            this.addEmptyDataRow();
        });
    }

    addContractedServices(companies) {
        this.addDataRow(['', '', 'Servi√ßos Contratados', '', '', '', '', '', '']);

        // Mapeamento de todos os servi√ßos dispon√≠veis
        const servicosDisponiveis = [
            { campo: 'bpo_contabil', nome: 'BPO Cont√°bil' },
            { campo: 'bpo_fiscal', nome: 'BPO Fiscal' },
            { campo: 'bpo_folha', nome: 'BPO Folha' },
            { campo: 'bpo_financeiro', nome: 'BPO Financeiro' },
            { campo: 'bpo_rh', nome: 'BPO RH' },
            { campo: 'bpo_cnd', nome: 'Certid√µes Negativas' }
        ];

        // Filtra apenas os servi√ßos contratados (que t√™m "Sim") e numera sequencialmente
        const servicosContratados = [];
        let numeroServico = 1;

        servicosDisponiveis.forEach(servico => {
            if (companies.some(c => c[servico.campo] === 'Sim')) {
                servicosContratados.push(['', '', `Servi√ßo ${numeroServico}:`, servico.nome, '', '', '', '', '']);
                numeroServico++;
                logger.info(`üìã Servi√ßo contratado: ${servico.nome}`);
            }
        });

        // Adiciona os servi√ßos contratados √† planilha
        servicosContratados.forEach(servico => {
            this.addDataRow(servico);
        });

        // Se nenhum servi√ßo foi contratado, adiciona uma linha indicando isso
        if (servicosContratados.length === 0) {
            this.addDataRow(['', '', 'Nenhum servi√ßo contratado', '', '', '', '', '', '']);
        }

        this.addEmptyDataRow();
    }

    addMainContact(companies) {
        const firstCompany = companies[0];
        
        this.addDataRow(['', '', 'Contato Principal', '', '', '', '', '', '']);
        this.addDataRow(['', '', 'Nome:', firstCompany.contato_principal_nome || '', '', '', '', '', '']);
        this.addDataRow(['', '', 'Cargo:', firstCompany.contato_principal_cargo || '', '', '', '', '', '']);
        this.addDataRow(['', '', 'E-mail:', firstCompany.contato_principal_email || '', '', '', '', '', '']);
        this.addDataRow(['', '', 'Celular:', firstCompany.contato_principal_celular || '', '', '', '', '', '']);
        this.addEmptyDataRow();
    }

    // Fun√ß√£o para adicionar entendimento do neg√≥cio - VERS√ÉO CORRIGIDA
    addBusinessUnderstanding(companies) {
        const chunks = this.chunkArray(companies, 3);
        
        chunks.forEach(chunk => {
            const headerRow = ['', '', 'Entendimento do Neg√≥cio'];
            chunk.forEach(company => {
                headerRow.push(this.truncateCompanyName(company.nome_fantasia));
            });
            while (headerRow.length < 9) headerRow.push('');
            this.addDataRow(headerRow);

            // ================== L√ìGICA DE FATURAMENTO CORRIGIDA ==================
            // Faturamento anual
            const faturamentoRow = ['', '', 'Faturamento anual:'];
            chunk.forEach(company => {
                const faturamentoString = company.faturamento_anual;
                
                if (typeof faturamentoString === 'string' && faturamentoString.trim() !== '') {
                    // Remove "R$" e espa√ßos
                    let valor = faturamentoString.replace(/R\$|\s/g, '');
                    
                    // Detecta o formato da moeda
                    let valorNumerico;
                    
                    // Formato brasileiro: R$ 3.500.000,00 (ponto = milhares, v√≠rgula = decimal)
                    if (valor.includes(',') && valor.lastIndexOf(',') > valor.lastIndexOf('.')) {
                        // Remove pontos (separadores de milhares) e substitui v√≠rgula por ponto
                        valorNumerico = parseFloat(valor.replace(/\./g, '').replace(',', '.'));
                        logger.info(`üí∞ Formato brasileiro detectado: "${faturamentoString}" ‚Üí ${valorNumerico}`);
                    }
                    // Formato americano: R$ 3,500,000.00 (v√≠rgula = milhares, ponto = decimal)
                    else if (valor.includes('.') && valor.lastIndexOf('.') > valor.lastIndexOf(',')) {
                        // Remove v√≠rgulas (separadores de milhares), mant√©m o ponto decimal
                        valorNumerico = parseFloat(valor.replace(/,/g, ''));
                        logger.info(`üí∞ Formato americano detectado: "${faturamentoString}" ‚Üí ${valorNumerico}`);
                    }
                    // Apenas n√∫meros com ponto (formato americano simples)
                    else if (valor.includes('.') && !valor.includes(',')) {
                        valorNumerico = parseFloat(valor);
                        logger.info(`üí∞ Formato americano simples: "${faturamentoString}" ‚Üí ${valorNumerico}`);
                    }
                    // Apenas n√∫meros com v√≠rgula (formato brasileiro simples)
                    else if (valor.includes(',') && !valor.includes('.')) {
                        valorNumerico = parseFloat(valor.replace(',', '.'));
                        logger.info(`üí∞ Formato brasileiro simples: "${faturamentoString}" ‚Üí ${valorNumerico}`);
                    }
                    // Apenas n√∫meros inteiros
                    else {
                        valorNumerico = parseFloat(valor);
                        logger.info(`üí∞ Formato num√©rico puro: "${faturamentoString}" ‚Üí ${valorNumerico}`);
                    }

                    if (!isNaN(valorNumerico) && valorNumerico > 0) {
                        // Adiciona o N√öMERO puro. A formata√ß√£o ser√° feita na escrita da planilha.
                        faturamentoRow.push(valorNumerico);
                    } else {
                        faturamentoRow.push('Sem Faturamento');
                        logger.info(`‚ùå Erro no faturamento: "${faturamentoString}" ‚Üí NaN`);
                    }
                } else {
                    faturamentoRow.push('Sem Faturamento');
                }
            });
            while (faturamentoRow.length < 9) faturamentoRow.push('');
            this.addDataRow(faturamentoRow);
            // ======================================================================

            const fields = [
                { label: 'Regime Tribut√°rio:', field: 'regime_tributario_atual', default: 'Lucro Presumido' },
                { label: 'NF de Entrada:', field: 'nf_entradas', default: 0, isNumeric: true },
                { label: 'NF de Sa√≠da:', field: 'nf_saidas', default: 0, isNumeric: true },
                { label: 'CT-es de Entrada:', field: 'ctes_entrada', default: 0, isNumeric: true },
                { label: 'CT-es de Sa√≠da:', field: 'ctes_saida', default: 0, isNumeric: true },
                { label: 'NF de Prestados:', field: 'nf_servicos_prestados', default: 0, isNumeric: true },
                { label: 'NF de Tomados:', field: 'servicos_tomados', default: 0, isNumeric: true },
                { label: 'Funcion√°rios PJ:', field: 'nf_pjs', default: 0, isNumeric: true },
                { label: 'Centros de Custo:', field: 'centro_custo_quantidade', default: 0, isNumeric: true }
            ];

            fields.forEach(({ label, field, default: defaultValue, isNumeric }) => {
                const row = ['', '', label];
                chunk.forEach(company => {
                    if (isNumeric) {
                        row.push(this.convertToNumber(company[field], defaultValue));
                    } else {
                        row.push(company[field] || defaultValue);
                    }
                });
                while (row.length < 9) row.push('');
                this.addDataRow(row);
            });

            this.addEmptyDataRow();
        });
    }

    addPayroll(companies) {
        const chunks = this.chunkArray(companies, 3);
        
        chunks.forEach(chunk => {
            const headerRow = ['', '', 'Folha de Pagamento'];
            chunk.forEach(company => {
                headerRow.push(this.truncateCompanyName(company.nome_fantasia));
            });
            while (headerRow.length < 9) headerRow.push('');
            this.addDataRow(headerRow);

            const fields = [
                { label: 'Funcion√°rios CLT:', field: 'colab_clt', isNumeric: true },
                { label: 'Pr√≥-Labore:', field: 'pro_labore', isNumeric: true },
                { label: 'Estagi√°rios:', field: 'estagiarios', isNumeric: true },
                { label: 'Aprendizes:', field: 'aprendizes', isNumeric: true },
                { label: 'Aut√¥nomos - RPA:', field: 'rpa', isNumeric: true },
                { label: 'Dom√©sticas CLT:', field: 'domesticas_clt', isNumeric: true }
            ];

            fields.forEach(({ label, field, isNumeric }) => {
                const row = ['', '', label];
                chunk.forEach(company => {
                    if (isNumeric) {
                        row.push(this.convertToNumber(company[field], 0));
                    } else {
                        row.push(company[field] || 0);
                    }
                });
                while (row.length < 9) row.push('');
                this.addDataRow(row);
            });

            this.addEmptyDataRow();
        });
    }

    addSystemsInfo(companies) {
        const firstCompany = companies[0];
        
        this.addEmptyDataRow();
        this.addDataRow(['', '', 'Sistemas', '', '', '', '', '', '']);
        this.addDataRow(['', '', 'Cont√°bil e Fiscal:', firstCompany.sistema_contabil || 'WK Radar', '', '', '', '', '']);
        this.addEmptyDataRow();
    }

    addAccountingInfo(companies) {
        const chunks = this.chunkArray(companies, 3);
        
        chunks.forEach(chunk => {
            const headerRow = ['', '', 'Contabilidade e Fiscal'];
            chunk.forEach(company => {
                headerRow.push(this.truncateCompanyName(company.nome_fantasia));
            });
            while (headerRow.length < 9) headerRow.push('');
            this.addDataRow(headerRow);

            const deadlineRow = ['', '', 'Deadline:'];
            chunk.forEach(company => {
                // Monta deadline din√¢mico baseado nos campos da API
                let deadline = '';
                if (company.deadline_periodicidade) {
                    deadline = `${company.deadline_util_corrente || 'Corrente'}, dia ${company.deadline_periodicidade}`;
                } else {
                    deadline = 'Trimestral, dia 30'; // Fallback
                }
                deadlineRow.push(deadline);
            });
            while (deadlineRow.length < 9) deadlineRow.push('');
            this.addDataRow(deadlineRow);

            const cnaeRow = ['', '', 'CNAE:'];
            chunk.forEach(company => {
                cnaeRow.push(company.atividade_especialidade || 'N√£o informado');
            });
            while (cnaeRow.length < 9) cnaeRow.push('');
            this.addDataRow(cnaeRow);

            this.addEmptyDataRow();
        });
    }

    addCommercialInfo(companies) {
        const firstCompany = companies[0];
        
        // Empresas abertas pela Go Further - agora vem da API
        this.addDataRow(['', '', 'Empresas abertas pela Go Further?', '', firstCompany.empresa_aberta_go || 'N√£o', '', '', '', '']);
        this.addEmptyDataRow();
        
        // Cobran√ßa de Implanta√ß√£o - agora vem da API
        this.addDataRow(['', '', 'Haver√° Cobran√ßa de Implanta√ß√£o:', '', firstCompany.implantacao || 'N√£o', '', '', '', '']);
        this.addDataRow(['', '', 'Vencimento:', '', 'Vencimento de forma conjunta ao primeiro honor√°rio mensal', '', '', '', '']);
        this.addEmptyDataRow();
        
        this.addDataRow(['', '', 'Faturar por:', '', '', '', '', '', '']);
        
        // Faturar por - agora vem da API
        if (companies.some(c => c.bpo_contabil === 'Sim')) {
            const faturadoContabil = firstCompany.bpo_contabil_faturado || 'GF Accounting';
            this.addDataRow(['', '', 'Cont√°bil', '', faturadoContabil, '', '', '', '']);
            logger.info(`üìã Cont√°bil faturado por: ${faturadoContabil}`);
        }
        
        if (companies.some(c => c.bpo_fiscal === 'Sim')) {
            const faturadoFiscal = firstCompany.bpo_fiscal_faturado || 'E.Reeve';
            this.addDataRow(['', '', 'Fiscal', '', faturadoFiscal, '', '', '', '']);
            logger.info(`üìã Fiscal faturado por: ${faturadoFiscal}`);
        }
        
        if (companies.some(c => c.bpo_cnd === 'Sim')) {
            const faturadoCnd = firstCompany.bpo_legal_faturado || 'E.Reeve';
            this.addDataRow(['', '', 'Certid√£o Negativa', '', faturadoCnd, '', '', '', '']);
            logger.info(`üìã Certid√£o Negativa faturada por: ${faturadoCnd}`);
        }
        
        this.addEmptyDataRow();
        
        this.addDataRow(['', '', 'Comercial', '', '', '', '', '', '']);
        this.addDataRow(['', '', 'Closer:', firstCompany.closer || '', '', '', '', '', '']);
        this.addDataRow(['', '', 'Prospector:', firstCompany.prospector || '', '', '', '', '', '']);
        
        if (firstCompany.observacoes_cadastro) {
            this.addDataRow(['', '', 'Obs:', firstCompany.observacoes_cadastro, '', '', '', '', '']);
        }
    }

    async generateForGroup(groupName) {
        try {
            logger.info(`Buscando dados para o grupo: ${groupName}`);
            const companies = await this.fetchGroupData(groupName);
            
            if (!companies || companies.length === 0) {
                throw new Error('Nenhuma empresa encontrada para o grupo especificado');
            }

            logger.info(`Encontradas ${companies.length} empresas. Gerando planilha...`);

            // Reset das vari√°veis para nova gera√ß√£o
            this.workbook = new ExcelJS.Workbook();
            this.worksheet = null;
            this.currentRow = 1;
            this.dataRows = [];

            this.companyNames = companies.map(company => this.truncateCompanyName(company.nome_fantasia)).filter(name => name.trim() !== '');
            logger.info(`üìã Nomes de empresas identificados: ${this.companyNames.length} (m√°x. ${this.maxCompanyNameLength} chars)`);

            logger.info('üìä Coletando todos os dados...');
            this.addGroupHeader(groupName);
            this.addCompanyBasicInfo(companies);
            this.addContractedServices(companies);
            this.addMainContact(companies);
            this.addBusinessUnderstanding(companies);
            this.addPayroll(companies);
            this.addSystemsInfo(companies);
            this.addAccountingInfo(companies);
            this.addCommercialInfo(companies);

            const fixedWidths = this.getFixedColumnWidths();

            this.worksheet = this.workbook.addWorksheet('Board');
            this.setupColumns(fixedWidths);

            this.writeDataToWorksheet();

            // Adiciona a imagem na linha 3
            await this.addImageToWorksheet();

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const fileName = `${groupName.replace(/\s+/g, '_')}_Ficha_Entrada_${timestamp}.xlsx`;
            const filePath = path.join(this.outputDir, fileName);
            
            logger.info('üíæ Salvando arquivo...');
            await this.workbook.xlsx.writeFile(filePath);

            logger.info('‚úÖ Planilha gerada com sucesso!');
            logger.info(`üìÅ Arquivo: ${fileName}`);
            logger.info(`üìà Total de empresas: ${companies.length}`);
            logger.info(`üìÑ Total de linhas: ${this.currentRow}`);

            return {
                success: true,
                fileName: fileName,
                filePath: filePath,
                stats: {
                    companies: companies.length,
                    rows: this.currentRow
                }
            };

        } catch (error) {
            logger.error('Erro ao gerar planilha:', error.message);
            throw error;
        }
    }

    // M√©todo para manter compatibilidade com controller existente
    async generateXlsx(empresas, tipoRelatorio, nomeGrupo, userId) {
        try {
            if (!nomeGrupo) {
                throw new Error('Nome do grupo √© obrigat√≥rio');
            }

            return await this.generateForGroup(nomeGrupo);
        } catch (error) {
            logger.error('Erro no generateXlsx:', error);
            throw error;
        }
    }

    async downloadFile(fileName) {
        const filePath = path.join(this.outputDir, fileName);
        
        if (!fs.existsSync(filePath)) {
            throw new Error('Arquivo n√£o encontrado');
        }

        return {
            filePath: filePath,
            fileName: fileName,
            mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        };
    }

    listAvailableFiles() {
        try {
            if (!fs.existsSync(this.outputDir)) {
                return [];
            }

            const files = fs.readdirSync(this.outputDir)
                .filter(file => file.endsWith('.xlsx'))
                .map(file => {
                    const filePath = path.join(this.outputDir, file);
                    const stats = fs.statSync(filePath);
                    
                    return {
                        fileName: file,
                        downloadUrl: `/api/xlsx-generator/download/${file}`,
                        tamanho: stats.size,
                        criadoEm: stats.birthtime,
                        modificadoEm: stats.mtime
                    };
                })
                .sort((a, b) => new Date(b.criadoEm) - new Date(a.criadoEm));

            return files;
        } catch (error) {
            logger.error('Erro ao listar arquivos:', error);
            return [];
        }
    }
}

module.exports = new XlsxGeneratorService();
